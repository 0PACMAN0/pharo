# Announcements framework## IntroductionThe announcement framwork is an event notification framework. Compared to "traditional" Smalltalk event systems in this new framework, an event is a real object rather than a symbol.An event someone might want to announce, such as a button click or an attribute change, is defined as a subclass of the abstract superclass Announcement. The subclass can have instance variables for additional information to pass along, such as a timestamp, or mouse coordinates at the time of the event, or the old value of the parameter that has changed. To signal the actual occurrence of an event, the "announcer" creates and configures an instance of an appropriate announcement, then broadcasts that instance. Objects subscribed to receive such broadcasts from the announcer receive a broadcast notification together with the instance. They can talk to the instance to find out any additional information about the event that has occurred.!## Tutorial### Step 1 - Define an announcememtTo define an announcement you just have to subclass the Announcement class:   Announcement subclass: #MyInterestingAnnouncement   	   instanceVariableNames: ''	   classVariableNames: ''	   poolDictionaries: ''	   category: 'MyApp-Core'	If required you can add instance variables to hold data that should be transferred when an announcement is made:   Announcement subclass: #GameLostAnnouncement	   instanceVariableNames: 'score'	   classVariableNames: ''	   poolDictionaries: ''	   category: 'MyGame-Core'### Step 2 - Publishers and subscribersIf an object wants to announce an event it needs someone to make the announcement to. This is typically an instance of class Announcer which acts as the mediator between the object that has to announce something (publisher) and one or many (anonymous) subscribers who are interested in the event.	| announcer |	announcer := Announcer new.	announcer announce: MyInterestingAnnouncement newUsing #announce: we can make an announcement - but since nobody is interested yet nothing will happen.Lets add some consumers/subscribers. Subscribers just register on the Announcer instance to note that they are interested on a particular event/announcement: 	| announcer |	announcer := Announcer new.		announcer when: MyInterestingAnnouncement send: #open to: Browser.     	announcer when: MyInterestingAnnouncement send: #inspect to: Smalltalk.    	So anytime an interesting announcement is made we want to inform the two consumers with a specific message. Still nothing happens - we have to additionally make the announcement:	| announcer |	announcer := Announcer new.		announcer when: MyInterestingAnnouncement send: #open to: Browser.    	announcer when: MyInterestingAnnouncement send: #inspect to: Smalltalk.    		announcer announce: MyInterestingAnnouncement new	Note that the subscribers are decoupled from the original announcement publisher. They dont have to know each other. Decoupling is the key thing here ... subscribers can register for particular events/announcements and remain anonymous to the original publisher. ### Step 3 - More examplesIn Pharo there is a global called "World" pointing to the desktop morph. This world also has an announcer we can use to demonstrate the features of the framework:	World announcer 		when: WindowOpened 		send: #value 		to: [ Transcript show: 'A new window was opened';cr].So anytime a window is opened in the system a message is shown in the transcript:			Transcript open.		World announcer 		when: WindowOpened 		send: #value 		to: [ Transcript show: 'A new window was opened';cr].## API Documentation### Announcements-Core#### AnnouncementThis class is the superclass for events that someone might want to announce, such as a button click or an attribute change. Typically you create subclasses for your own events you want to announce.See in the help browser for more documentation. Just do:HelpBrowser openOn: AnnouncementsHelp##### Instance sideAnnouncement>>#affectsClass:Method has no comment.Announcement>>#affectsClassExtensionMethod has no comment.Announcement>>#affectsClassesMethod has no comment.Announcement>>#affectsClassesDefinedInPackage:Method has no comment.Announcement>>#affectsClassesExtendedInPackage:Method has no comment.Announcement>>#affectsCritiquesCritiques are very abstract concept. Any change can affect critique of arbitrary objectAnnouncement>>#affectsMethod:Method has no comment.Announcement>>#affectsMethodTagIn:Method has no comment.Announcement>>#affectsMethodsMethod has no comment.Announcement>>#affectsMethodsDefinedInClass:Method has no comment.Announcement>>#affectsMethodsDefinedInPackage:Method has no comment.Announcement>>#affectsMethodsTaggedWith:Method has no comment.Announcement>>#affectsPackage:Method has no comment.Announcement>>#affectsPackagesMethod has no comment.Announcement>>#affectsVariablesOf:Method has no comment.Announcement>>#asAnnouncementMethod has no comment.Announcement>>#canAffectResultOfMethodQuery:Method has no comment.Announcement>>#emitConvert the receiver as a beacon signal to the main signal dispatcher so that registered loggers get a chance to act on signal reception.Announcement>>#prepareForDeliveryThis method will be executed once before subscriptions delivery.	If nobody subscribed on me this method will not be called.	It allows to put some heavy initialization logic here. It will be executed only 	if there is interest on meAnnouncement>>#shouldBeConsideredByCalypsoEnvironmentMethod has no comment.##### Class sideAnnouncement class>>#,Method has no comment.Announcement class>>#-Create an announcement set containing the receiver 	and anotherAnnouncement as exclusion.Announcement class>>#asAnnouncementMethod has no comment.Announcement class>>#handlesAnnouncement:The receiver acts as a filter to determine whether subscribers who used the receiver as signaling tag (event identifier class or symbol) should receive incoming announcement. In particular, registering to a superclass will receive the announcements from all subclasses.Announcement class>>#systemIconNameMethod has no comment.Announcement class>>#where:Method has no comment.#### AnnouncementDeliveryConditionI represent condition which should be satisfied on given announcement to be delivered to subscription.I am used to implement instance specific subscription on announcements. To create me send message #where to announcement class with condition block:	Announcement where: [ :ann | ann param = #expected ]I can be used directly in announcer subscription API in place of announcement class:	announcer when:  (ValueChanged where: [:change | change oldValue = 100])Be carefull with me because blocks in subscriptions produce references to outer contexts (recever and all senders) Internal Representation and Key Implementation Points.    Instance Variables	announcementClass:		<Announcement class>	conditionBlock:		<BlockClosure>##### Instance sideAnnouncementDeliveryCondition>>#announcementClassMethod has no comment.AnnouncementDeliveryCondition>>#announcementClass:Method has no comment.AnnouncementDeliveryCondition>>#conditionBlockMethod has no comment.AnnouncementDeliveryCondition>>#conditionBlock:Method has no comment.AnnouncementDeliveryCondition>>#handlesAnnouncement:Method has no comment.##### Class sideAnnouncementDeliveryCondition class>>#for:where:Method has no comment.#### AnnouncementSetIf you want to register the same action for multiple events, simply create an AnnouncementSet using a comma: 	Parent>>initialize 	    super initialize. 	    self session announcer on: AddChild, RemoveChild do: [:it | self changeChild: it child]	Motivation example: Often the UI is built after/independently from the model. You want to have the model raise fine-grained announcements to enable the layers on top, but sometimes it is easier in the UI to refresh everything whenever something happens.##### Instance sideAnnouncementSet>>#,Method has no comment.AnnouncementSet>>#-Create an announcement set containnig the receiver	and anotherAnnouncement as an exclusion.AnnouncementSet>>#handlesAnnouncement:If any of the set handles the announcements, subscribers should receive it.##### Class side#### AnnouncementSetWithExclusionsI am an AnnouncementSet that explicitely does not handle a number of exclusion Announcements.You could define me by #- message:	announcer when: Announcement - ValueChanged do: [...].	announcer when: Announcement - ValueChanged - ValueAdded do: [...].	announcer when: ValueAdded, ValueRemoved - ValueAdded Internal Representation and Key Implementation Points.    Instance Variables	exclusions:		<OrderedCollection>##### Instance sideAnnouncementSetWithExclusions>>#addExclusion:Add anAnnouncement as an exclusion to me.	I will explicitly not handle my exclusion announcements.AnnouncementSetWithExclusions>>#handlesAnnouncement:Return true when I will handle anAnnouncement.	I extend my superclass behavior by explicitly 	not handling the exclusions.AnnouncementSetWithExclusions>>#initializeMethod has no comment.AnnouncementSetWithExclusions>>#initialize:Method has no comment.##### Class side#### AnnouncementSubscriptionThe subscription is a single entry in a SubscriptionRegistry.Several subscriptions by the same object is possible.I know how to make myself weak or strong, only use this capability if it can't be determined at subscribe time though, as it uses become: (for thread-safety), which is quite slow.##### Instance sideAnnouncementSubscription>>#actionMethod has no comment.AnnouncementSubscription>>#action:Method has no comment.AnnouncementSubscription>>#announcementClassMethod has no comment.AnnouncementSubscription>>#announcementClass:Method has no comment.AnnouncementSubscription>>#announcerMethod has no comment.AnnouncementSubscription>>#announcer:Method has no comment.AnnouncementSubscription>>#deliver: deliver an announcement to receiver. In case of failure, it will be handled in separate processAnnouncementSubscription>>#handlesAnnouncement:Method has no comment.AnnouncementSubscription>>#makeStrong i am already strong. Do nothing AnnouncementSubscription>>#makeWeakMethod has no comment.AnnouncementSubscription>>#subscriberMethod has no comment.AnnouncementSubscription>>#subscriber:Method has no comment.AnnouncementSubscription>>#valuable:Used when subscriber should be extracted from valuable object##### Class side#### AnnouncerThe implementation uses a threadsafe subscription registry, in the sense that registering, unregistering, and announcing from an announcer at the same time in different threads should never cause failures.##### Instance sideAnnouncer>>#announce:Method has no comment.Announcer>>#basicSubscribe:Method has no comment.Announcer>>#handleEventClass:Return true if the receiver has a callback subscripbed for the event classAnnouncer>>#handleSubscriberClass:Method has no comment.Announcer>>#hasSubscriber:Method has no comment.Announcer>>#hasSubscriptionsMethod has no comment.Announcer>>#initializeMethod has no comment.Announcer>>#inspectionSubscriptionsMethod has no comment.Announcer>>#inspectionSubscriptionsContext:Method has no comment.Announcer>>#numberOfSubscriptionsMethod has no comment.Announcer>>#removeSubscription:Remove the given subscription from the receiverAnnouncer>>#replace:with:Method has no comment.Announcer>>#subscriptionsMethod has no comment.Announcer>>#subscriptionsForClass:Return the list of subscription for a given classAnnouncer>>#unsubscribe:Unsubscribe all subscriptions of anObject from the receiverAnnouncer>>#weakannouncer weak subscribe: fooAnnouncer>>#when:do:Declare that when anAnnouncementClass is raised, aValuable is executed.  Pay attention that such method as well as #when:do: should not be used on weak announcer since the block holds the receiver and more strongly.Announcer>>#when:do:for:Declare that when anAnnouncementClass is raised, aValuable is executed and define the subscriber.Announcer>>#when:send:to:Declare that when anAnnouncementClass is raised, anObject should receive the message aSelector.    When the message expects one argument (eg #fooAnnouncement:) the announcement is passed as argument.    When the message expects two arguments (eg #fooAnnouncement:announcer:) both the announcement and     the announcer are passed as argument##### Class side#### ManifestAnnouncementsCoreA package with classes for the announcement framwork - an event notification framework.##### Instance side##### Class sideManifestAnnouncementsCore class>>#manuallyResolvedDependenciesMethod has no comment.#### SubscriptionRegistryThe subscription registry is a threadsafe storage for the subscriptions to an Announcer.In Pharo, subscriptionsFor: protocol is not implemented.This is because Announcer does not provide public access to its registery for encapsulation reasons.(We do not want access to the announcer from action blocks to break encapsulation to other subscribers)##### Instance sideSubscriptionRegistry>>#add:Method has no comment.SubscriptionRegistry>>#deliver:Method has no comment.SubscriptionRegistry>>#deliver:to:Method has no comment.SubscriptionRegistry>>#deliver:to:startingAt:Method has no comment.SubscriptionRegistry>>#getInteractionsForClass:Return the list of subscription for a given Event classSubscriptionRegistry>>#handleEventClass:Return true if the receiver has a callback subscripbed for the event classSubscriptionRegistry>>#handleSubscriberClass:Return true if the receiver has a callback subscripbed for the event classSubscriptionRegistry>>#initializeMethod has no comment.SubscriptionRegistry>>#inspectionSubscriptionsMethod has no comment.SubscriptionRegistry>>#numberOfSubscriptionsMethod has no comment.SubscriptionRegistry>>#protected:Method has no comment.SubscriptionRegistry>>#remove:Method has no comment.SubscriptionRegistry>>#removeSubscriber:Method has no comment.SubscriptionRegistry>>#replace:with: Note that it will signal an error if subscription is not there SubscriptionRegistry>>#resetsubscriber -> subscriptionsSubscriptionRegistry>>#subscriptionsMethod has no comment.SubscriptionRegistry>>#subscriptionsForClass:Return the list of subscription for a given classSubscriptionRegistry>>#subscriptionsHandling:Method has no comment.SubscriptionRegistry>>#subscriptionsOf:do:Method has no comment.##### Class side#### WeakAnnouncementSubscriptionA WeakAnnouncementSubscription is a subscription which is removed automatically when the subscriber is unreferenced.No support for ephemerons currently prevents this from working for Block actions (blocks hold their receiver, which is the default subscriber strongly). To switch between subscription types, use makeStrong/makeWeak on the subscription returned when initially registering with announcer.Note, that list and next must be first instance variables.##### Instance sideWeakAnnouncementSubscription>>#actionMethod has no comment.WeakAnnouncementSubscription>>#action:Method has no comment.WeakAnnouncementSubscription>>#announcementClassMethod has no comment.WeakAnnouncementSubscription>>#announcementClass:Method has no comment.WeakAnnouncementSubscription>>#announcerMethod has no comment.WeakAnnouncementSubscription>>#announcer:Method has no comment.WeakAnnouncementSubscription>>#deliver: deliver an announcement to receiver. In case of failure, it will be handled in separate processWeakAnnouncementSubscription>>#finalizeMethod has no comment.WeakAnnouncementSubscription>>#handlesAnnouncement:Method has no comment.WeakAnnouncementSubscription>>#initializeMethod has no comment.WeakAnnouncementSubscription>>#makeStrongMethod has no comment.WeakAnnouncementSubscription>>#makeWeakMethod has no comment.WeakAnnouncementSubscription>>#nextMethod has no comment.WeakAnnouncementSubscription>>#printOn:Method has no comment.WeakAnnouncementSubscription>>#registerMethod has no comment.WeakAnnouncementSubscription>>#subscriberMethod has no comment.WeakAnnouncementSubscription>>#subscriber:Method has no comment.WeakAnnouncementSubscription>>#unregisterMethod has no comment.WeakAnnouncementSubscription>>#valuable:Used when subscriber should be extracted from valuable objectWeakAnnouncementSubscription>>#weakRegistryMethod has no comment.##### Class sideWeakAnnouncementSubscription class>>#finalizationListMethod has no comment.WeakAnnouncementSubscription class>>#finalizeValuesMethod has no comment.WeakAnnouncementSubscription class>>#initializeself initializeWeakAnnouncementSubscription class>>#newMethod has no comment.#### WeakSubscriptionBuilderI am a wrapper around an Announcer, used to create weak subscriptions at subscription time.Use me like this:anAnnouncer weak subscribe: Announcement send: #foo to: barObject.I raise an error for block subscriptions, as they require non-existing Ephemeron support to function correctly.##### Instance sideWeakSubscriptionBuilder>>#announcer:Method has no comment.WeakSubscriptionBuilder>>#weakalready weakWeakSubscriptionBuilder>>#when:do:Do not use this message on weak announcer because it does not work. The block will hold strongly the receiver and more.	 We need ephemerons for that'WeakSubscriptionBuilder>>#when:send:to:Method has no comment.##### Class sideWeakSubscriptionBuilder class>>#on:Method has no comment.### Announcements-View### Announcements-Core-Tests#### AnnouncementMockAThis is a simple test mock.##### Instance side##### Class side#### AnnouncementMockBThis is a simple test mock##### Instance sideAnnouncementMockB>>#parameterMethod has no comment.AnnouncementMockB>>#parameter:Method has no comment.##### Class sideAnnouncementMockB class>>#with:Method has no comment.#### AnnouncementMockCThis is a simple test mock##### Instance sideAnnouncementMockC>>#announcingCounterMethod has no comment.AnnouncementMockC>>#initializeMethod has no comment.AnnouncementMockC>>#prepareForDeliveryMethod has no comment.##### Class side#### AnnouncementSetTestSUnit tests for announcement sets##### Instance sideAnnouncementSetTest>>#testIncludeOnlyOnceMethod has no comment.AnnouncementSetTest>>#testInstanceCreationMethod has no comment.##### Class side#### AnnouncerSubscriberMockAI am a mock class for testing in announcers##### Instance sideAnnouncerSubscriberMockA>>#announcerMethod has no comment.AnnouncerSubscriberMockA>>#announcer:Method has no comment.AnnouncerSubscriberMockA>>#registerEventsMethod has no comment.##### Class side#### AnnouncerSubscriberMockBI am a mock class for testing in announcers##### Instance side##### Class side#### AnnouncerTestAn AnnouncerTest is a test class used to test Announcer.Instance Variables	announcer:		<Announcer>  the announcer to testannouncer	- the announcer that is tested##### Instance sideAnnouncerTest>>#newAnnouncerMethod has no comment.AnnouncerTest>>#setUpMethod has no comment.AnnouncerTest>>#testAccessingSubscribersMethod has no comment.AnnouncerTest>>#testAnnounceClassMethod has no comment.AnnouncerTest>>#testAnnounceInstanceMethod has no comment.AnnouncerTest>>#testAnnounceWorkWithinExceptionHandlerBlocksMethod has no comment.AnnouncerTest>>#testAnnouncingReentrantTest that it is safe to announce when handling announcement,	so announcer are reentrantAnnouncerTest>>#testHandleSubscriberClassMethod has no comment.AnnouncerTest>>#testNoArgBlockwe are supposed to accept zero-argument blocks as actions AnnouncerTest>>#testPreparationAnnouncementDeliveryMethod has no comment.AnnouncerTest>>#testPreparationAnnouncementDeliveryWhenNoSubscriptionsMethod has no comment.AnnouncerTest>>#testSubscribeBlockMethod has no comment.AnnouncerTest>>#testSubscribeClassWithExclusionMethod has no comment.AnnouncerTest>>#testSubscribeOnSpecificAnnouncerMethod has no comment.AnnouncerTest>>#testSubscribeSendMethod has no comment.AnnouncerTest>>#testSubscribeSetMethod has no comment.AnnouncerTest>>#testSubscribeSetWithExclusionMethod has no comment.AnnouncerTest>>#testSubscribeSetWithExclusionOfMultipleAnnouncementsMethod has no comment.AnnouncerTest>>#testSubscribeSetWithExclusionOfSetItemMethod has no comment.AnnouncerTest>>#testSubscribeSubclassMethod has no comment.AnnouncerTest>>#testSubscribersForClassMethod has no comment.AnnouncerTest>>#testSymbolIdentifierMethod has no comment.AnnouncerTest>>#testTwoArgBlockwe are supposed to accept two-argument blocks as actions AnnouncerTest>>#testUnsubscribeBlockMethod has no comment.AnnouncerTest>>#testUnsubscribeSendMethod has no comment.AnnouncerTest>>#testUnsubscribeSetMethod has no comment.##### Class sideAnnouncerTest class>>#shouldInheritSelectorsMethod has no comment.#### WeakAnnouncerTestSUnit tests for weak announcements##### Instance sideWeakAnnouncerTest>>#benchManyWeakGuysMethod has no comment.WeakAnnouncerTest>>#benchWeakSubscriptionDynamicRun me to see how expensive #becomeForward: is (compared to #benchWeakSubscriptionStatic )WeakAnnouncerTest>>#benchWeakSubscriptionStaticRun me to see how cheap object creation is (compared to #benchWeakSubscriptionDynamic ) WeakAnnouncerTest>>#longTestCaseMethod has no comment.WeakAnnouncerTest>>#testNoDeadWeakSubscriptionsMethod has no comment.WeakAnnouncerTest>>#testNoWeakBlockThere is no such thing as a weak block, these things never go away.WeakAnnouncerTest>>#testWeakDoubleAnnouncerMethod has no comment.WeakAnnouncerTest>>#testWeakObjectMethod has no comment.WeakAnnouncerTest>>#testWeakSubscriptionMethod has no comment.WeakAnnouncerTest>>#testWeakSubscriptionReleaseThis test shows the a problem with weak registrations not garbage collected in Spur.	 See https://pharo.manuscript.com/f/cases/17537 for more details.##### Class side