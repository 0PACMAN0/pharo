# RPackage## RPackageA RPackage is a new implementation of package. Note that it does not touch classes but it is just a layer on top of classes therefore removing a method from a package does not change the underlying class. Instance Variables	classDefinedSelectors:		Dictionary	classExtensionSelectors:		Dictionary	metaclassDefinedSelectors:		Dictionary	metaclassExtensionSelectors:		Dictionary	packageName:		String	classes: OrderedCollection of Symbols	classTags: is a mapping from tags to classNamesThe reason we use four dictionaries is that this way we only store #Point in both as the class and the metaclass are involved. We do not have to with Point_class problem when comparing defined and extended classes. The idea is taken from the RBSelectorEnvironment. 							Class Invariant one:	Classes should not contain metaclass name, but only class names		Implementation notes ====================This class went over 3 internal representations implementation. 	- first: 	a list of class + two dictionaries: class * methods	This was not good since we add to go all the time over the list of classes.	- second: 4 dictionaries class * selectors 	This was not good since we want to have defined classes without methods. 	- third: 4 dictionaries + definedClassesOriginally I wanted to avoid to have a defined class list and I wanted to avoid to have to declare the class as defined. But this is not really good since	- we will want to know if a class definition (without method for example is defined in a given package)	- second this is easier to hook the packageOf: behavior (we register the package class when the class is 	added to the package).defined classes information is redundant with the dictionary keys of defined methods but we would have to check and register the class to the packageOrganizer the first time a method is defined then also check on remove to unregister the class from the packageOrganizer.Adding a method does not define the class as a defined package class. This has to be done explictly. The reason for this choice is that a class should register to the packageOrganizer and that I do not want to do it each time a method is added and I do not want to test it each time a method is added. Now this is done only when the class is declared as defined. We could also give the complete freedom to the client to register the class but I thought it was a good compromise. 		ClassTag are tags that can be associated to classes. They help user organizing their class internal. So that we can have a package infrastructure as follows:	Package1		ClassA		ClassB	in case there is no tags associated to the package	or	Package2			Tag1			ClassA			ClassB		Tag2			ClassC			ClassD			ClassE			ClassA			Todo====	Next: 	- finish 	- build up a synchronizer that import PackageInfo.			## RPackageOrganizerA RPackageOrganizer is responsible for providing all the package currently defined in the system.In addition it provides a back pointer from the class to its package.The classPackageMapping and the classExtendingPackageMapping should be moved in the future to the classes themselves. For tests or actions that could destroy the package organizer,  do not access directly the singleton of RPackageOrganizer.Use instead 		RPackage withOrganizer: aNewOrganizer do: ablock			or via RPackage organizer			RPackageOrganizer fillUp will fill up the system from the current PackageOrganizer	"self fillUp"	-----------------------------------------------------------------------------------------------------------------------------------------------			A rpackageOrganizer update itself when some changes are made in the system. It does that by registering to a systemAnnoucer, specifying an action when an annoucement is triggered.Here is what I (Cyrille Delaunay) propose to do for each annocuement triggered:SystemCategoryAddedAnnouncement 		=> I would just register a new RPackage (if it does not already exist) in the RPackageOrganizer	SystemCategoryRemovedAnnouncement      => I would just unregister the RPackage concerned from the organizerSystemCategoryRenamedAnnouncement     => I would update the RPackage concerned, by changing its name     => I would update the 'packages' dictionary of the organizer, putting the new name as keySystemClassAddedAnnouncement     => Import the class in the RPackage concerned (RPackage >> importClass:)    => Register the class in the 'classPackageMapping' dictionary of the organizer (RPackageOrganizer >> registerPackage:forClass)    (=> maybe we should pay attention if both the class and the metaclass launch this kind of event ?)SystemClassRecategorizedAnnouncement    => I would update the old RPackage concerned:            => unregister the class            => unregister all defined methods of the class    => I would update the new RPackage:            => Import the class in the RPackage (importClass:)    => I would update the organizer:            => update the 'classPackageDictionary' to point on the new RPackage SystemClassRemovedAnnouncement    => I would update the RPackake concerned             => unregister the class             => unregister all defined methods of the class    => I would update the organizer:             => update the 'classPackageDictionary' to remove the classSystemClassRenamedAnnouncement    => I would update the RPackage in which the class is defined:             => update the 'classDefinedSelectors' dictionary (replace the old key by the new one)             => update the 'metaclassDefinedSelectors' dictionary (replace the old key by the new one)    => I would update all RPackages extending this class             => update the 'classExtensionsSelectors' dictionary (replace the old key by the new one)             => update the 'metaclassclassExtensionsSelectors' dictionary (replace the old key by the new one)    => I would update the organizer             => update the 'classPackageDictionary' to replace the key with the new class name             => update the 'classExtendingPackagesMapping' to replace the key with the new class name                          SystemClassReorganizedAnnouncement     (=> I guess we should check if extensions have not been added or removed ?       (to retrieve this information, the only thing I found is ClassDescription >> organization, and then check each category begining with '*' and compare with the organizer. seems to be painful, no?))	=> when an extension is removed, all methods inside are removed. Therefore, the MethodRemovedAnnounecement will do the job. Not sur this one still usefullSystemProtocolAddedAnnouncement    => I don't see anything to do for this annoucementSystemProtocolRemovedAnnoucement    => If the category is an extension from a package, I would move all the methods concerned, from the extending RPackage to the class RPackageSystemMethodAddedAnnouncement       => I would check the category in which the method has been defined               => if it correspond to an extending package -> add the method to the extending RPackage               => if not, add the method to the class parentPackageSystemMethodModifiedAnnouncement       this annoucement can correspond to several kind of modifications:	       *  a method has been renamed                       => I would update the rPackage in which the method is defined to replace the old selector by the new one		* a method has been move to another category 			-maybe from a classic category to an extending package                             => we should move the method from the  method class parentPackage to extendingPackage package			-maybe from an extending package to another extending package                             => we should move the method from the  extendingPackage package to the other extendingPackage package			-maybe from an extending package to a classic category                             =>  we should move the method from the  extendingPackage to the method class parentPackage		        -maybe from a classic category to another classic category                             => we have nothing to do			SystemMethodRecategorizedAnnouncement          same thing than aboveSystemMethodRemovedAnnouncement       => I would simply remove the method from the RPackage in which it is register