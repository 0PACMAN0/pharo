# Spec## About SpecSpec has been originally developed by B. Van Ryseghem based on an idea of S. Ducasse. It is now maintained by the community and the pharo core team.Spec is an attempt to support UI logic reuse. Spec is influenced by VisualWorks and Dolphin MVP in the sense that it recognizes the need for a Presenter or Application-Model class, in Spec called SpPresenter that manages the logic and the link between widgets and domain objects. Spec, following the tradition, uses value holders, simple object raising announcements when their values, often domain objects, change.## TerminologyTo avoid possible misunderstandings due to confusion in terminology, we first define the following four terms, which will be used frequently:UI Element: an interactive graphical element displayed as part of the graphical user interface.UI Model: an object that contains the state and behavior of one or several UI elements.Widget: the union of a UI Element and its UI model.Basic Widgets: low level widgets like## Examples### A first example: ModelListCreating a specific UI always starts with the subclassing of SpPresenter. Each sub widget is stored into an instance variable of the newly created class. All the code presented here is already in the image so you can simply do: 			ModelList browseAnd follow the tutorial while browsing the code. So let's subclass SpPresenter.	SpPresenter subclass: #ModelList	instanceVariableNames: 'list'	classVariableNames: '	category: 'Spec-Examples'				The first required step then is to instantiate and define the sub widgets. This step is done in the method initializeWidgets. It creates the list and populates it with the required classes, in alphabetical order.	ModelList>>initializeWidgets	list := self newList.	list items: (AbstractWidgetPresenter allSubclasses	sorted: [:a :b | a name < b name ]).	self focusOrder add: list	The second required step is to define a layout, which is done on the class side. Since there is here only one sub widget, the layout is quite simple. It simply returns a layout that contains only the list:	ModelList class>>#defaultSpec	<spec: #default>	^ SpecLayout composed	add: #list;	yourself	The three last methods to define on ModelList are a getter, a method to display the UI title and a method to register to list selection changes.	"accessing"	ModelList>>list		^ list	"api"	ModelList>>title		^ 'Widgets'	"api-events"	ModelList>>whenSelectedItemChanged: aBlock		list whenSelectedItemChanged: aBlockThe first UI is now done. The result can be seen by executing the following snippet of code: 	ModelList new openWithSpec.### A second example: Protocol ListThe next user interface is the protocol list. This UI combines two sub widgets: 		a list		a label.So again, we start by subclassing SpPresenter	SpPresenter subclass: #ProtocolList	instanceVariableNames: 'label protocols'	classVariableNames: '	category: 'Spec-Examples'	The initializeWidgets method for this UI is quite similar to the method in ModelList:	ProtocolList>>initializeWidgets		protocols := self newList.		label := self newLabel.		label text: 'Protocol'.		protocols displayBlock: [ :m | m selector ].		self focusOrder add: protocols	The layout method is quite different though. Now the sub widgets need to be placed more specifically than in the previous example, we have to build a layout that has a column with the label on top and the list taking all the space that is left.	ProtocolList class>>defaultSpec		<spec: #default>		^ SpecLayout composed		newColumn: [ :column |			column				add: #label					height: self toolbarHeight;					add: #protocols ];		yourself			The remaining methods are getters, sub widget delegation methods, a method to display the title, and a method to register to list selection changes: 	"accessing"	ProtocolList>>label		^ label	"accessing"	ProtocolList>>protocols		^ protocols	"api"	ProtocolList>>items: aCollection		protocols items: aCollection	"api"	ProtocolList>>label: aText		label label: aText	"api"	ProtocolList>>resetSelection		protocols resetSelection	"api"	ProtocolList>>title		^ 'Protocol widget'	"api-events"	ProtocolList>>whenSelectedItemChanged: aBlock		protocols whenSelectedItemChanged: aBlockThe ProtocolList UI can be seen by evaluating: ProtocolList new openWithSpec.### More ExamplesIf you browse the Spec-Examples package you will find a lot more examples that will help you understand Spec a little more.		ApplicationWithToolbar new openWithSpecCheckBoxExample new openWithSpecClassMethodBrowser new openWithSpecDropListExample new openWithSpecDynamicWidgetChange new openWithSpecListSelectionPresenter new openWithSpecMethodBrowser new openWithSpecModelList new openWithSpecProtocolBrowser new openWithSpecProtocolList new openWithSpecProtocolViewer new openWithSpecRadioButtonGroupExample new openWithSpecScrollSyncExample new openWithSpecTabsExample new openWithSpecTextFieldExample new openWithSpec## The Heart of Spec### The Heart of SpecAll user interfaces in Spec are constructed through the composition of existing user interfaces. To define a user interface, it is sufficient to define the model of the user interface. The UI elements that correspond to this model are instantiated by Spec, depending on the underlying UI framework. 		It is the composition of this model and these UI elements that makes up the resulting widget that is shown to the user, i.e. the resulting user interface. Hence, since all UIs are constructed through composition of other UIs, and it is sufficient to define the model to define the UI, the root class of all UIs is named SpPresenter. So, to define a new user interface, a subclass of SpPresenter needs to be created.Spec is inspired by the MVP pattern. It is built around three axes that materialize themselves as the following three methods: SpPresenter>>#initializeWidgetsSpPresenter>>#initializePresenterSpPresenter class>>#defaultSpec. 	These methods are hence typically found in the model for each user interface. In the following topics we describe the responsibility for each method, i.e. how these three work together to build the overall UI.### The initializeWidgets methodThis method is used to instantiate the models for the different widgets that will be part of the UI and store them in their respective instance variables. Instantiation of the models will in turn result in the instantiation and initialization of the different widgets that make up the UI. Consequently, configuration and default values of each widget are specified here as well, which is why this method is called initializeWidgets. This focus in this method is to specify what the widgets will look like and what their self-contained behavior is. The behavior to update model state, e.g. when pressing a Save button, is described in this method as well. It is explicitly not the responsibility of this method to define the interactions between the widgets.In general the initializeWidgets method should follow the pattern:• widgets instantiation• widgets configuration specification• specification of order of focusThe last step is not mandatory but highly recommended. Indeed, without this final step keyboard navigation will not work at all.An example of the initializeWidgets method could be:	initializeWidgets		theButton := self newButton.		theList := self newList.		theButton label: 'I am a button'.		self focusOrder		add: theButton;		add: theList.Specifying this method is mandatory, as without it the UI would have no widgets.### Widget InstantiationThe instantiation of the model for a widget (and hence the widget) can be done in two ways: Through the use of an creation method or through the use of the instantiate: method. Considering the first option, the framework provides unary messages for the creation of all basic widgets. The format of these messages is:   	new[Widget]for example newButton creates a button widget, and newList creates a list widget. The complete list of available widget creation methods can be found in the class Composable-Model in the protocol widgets. Considering the second option, to reuse any composite widgets, i.e. a subclass of SpPresenter, the widget needs to be initialized using the instantiate: method. For example, to reuse a Message-Browser widget, the code is:	self instantiate: MessageBrowser.### The initializePresenter methodThis method takes care of the interactions between the different widgets. By linking the behavior of the different widgets it specifies the overall presentation, i.e. how the overall UI responds to interactions by the user. Usually this method consists of specifications of actions to perform when a certain event is received by a widget. From the propagation of those events the whole interaction flow of the UI emerges. In Spec, the different UI models are contained in value holders, and the event mechanism relies on the announcements of these value holders to manage the interactions between widgets. Value holders provide a single method whenChangedDo: that is used to register a block to perform on change. In addition to this primitive whenChangedDo: method, the basic widgets provide more specific hooks, e.g. when an item in a list is selected or deselected.### The layout methodThis method specifies the layout of the different widgets in the UI. It also specifies how a widget reacts when the window is resized. For the same UI multiple layouts can be described, and when the UI is built a specific layout to use can be specified. If no such specific layout is given, the following lookup mechanism will be used to obtain the layout method:1. Search on class side, throughout the whole class hierarchy, for a method with the pragma <spec: #default>.2. If multiple such methods exist, the first one found is used.3. If none such methods exist and if there is exactly one method with the pragma <spec>, this method is used.4. No layout method is found, an error is raised.This method is on class side because it returns a value that usually is the same for all the instances. Put differently, usually all the instances of the same user interface have the same layout and hence this can be considered as being a class-side accessor for a class variable. Note that the lookup for the spec method to use starts on instance side, which allows a UI to have a more specific layout depending on the state of the instance.In its simplest form, this method could be:	^ SpecLayout composed			add: #theList;			yourselfThe symbol theList refers to an instance side method returning a widget. This is because instance variables are private, so the layout class needs to use an accessor to obtain it when building the UI. Note that by default, a widget will take all the space available in its container.This method is not restricted to laying out sub widgets. It can also refer to sub widgets contained in sub widgets, i.e. when reusing an existing UI, specify a new layout for the sub widgets that comprise this UI. To do this, instead of giving a symbol, an array with 2 symbols must be given. The first symbol identifies the UI being reused and the second the sub widget within this UI whose new layout position is being specified. As said above, multiple layouts can be described for the same user interface. In order to retrieve the correct method to apply, these methods need to be flagged with a pragma. The pragma can be either <spec: default> for the layout to use by default, or <spec> for the other layouts.Specifying this method is mandatory, as without it the UI would show no widgets to the user.## Spec Layouts### LayoutsAs layouts can become quite complex, this section provides a list of examples of the construction of layouts.  All the methods for adding sub widgets can be found in the 'commands' and 'commands-advanced' protocols of the SpecLayout class. You can explore them by doing:			SpecLayout browse				Often the layout of user interfaces can be described in rows and columns, and Spec provides for an easy way to specify such layouts.### Layouts in columnsHaving the widgets rendered as a column is easy:	^ SpecLayout composed			newColumn: [ :column |				column					add: #theList;					add: #theButton			];			yourself### Layouts in rowsIf you want to arrange your widgets in a row, that's simple:					^ SpecLayout composed			newRow: [ :row |				row					add: #theList;					add: #theButton			];			yourself### Combining Columns and RowsRows and columns can be combined to build more complex layouts, and splitters between cells can be added. The example 1.24 shows how to create a 3 columns layout, containing three buttons in each column. This example also shows the addSplitter message, which adds a splitter between the element added before it and the element added after.	^ SpecLayout composed			newRow: [ :row |				row					newColumn: [ :column |						column							add: #button1;							add: #button2;							add: #button3					];					addSplitter;					newColumn: [ :column |						column							add: #button4;							add: #button5;							add: #button6					];					addSplitter;					newColumn: [ :column |						column							add: #button7;							add: #button8;							add: #button9					];			];			yourselfThe height of rows as well as the width of columns can be specified, to prevent them to take all the available space.  Here is an example of a row with a height of 30.		^ SpecLayout composed				newRow: [ :row |					row						add: #theList;						add: #theButton				] height: 30;				yourself								And the same but for a column:		^ SpecLayout composed				newColumn: [ :column |					column						add: #theList;						add: #theButton				] width: 30;			    yourself						Note that it is generally considered a bad habit to hardcode the size of the widgets. Methods are available on SpPresenter providing sensible default sizes, like the width of a button. When specifying custom widget sizes, care should be taken to take in account the current font size.## InspectorPharo offers a Spec-based inspector. Inspecting an object opens an inspector that is built using Spec.You can particularize the inspector in numerous way. For example, consider the following code:```OrderedCollection>>inspectorText	<inspectorPresentationOrder: 90 title: 'My description'>	^ SpTextPresenter new		text: 'OrderedCollection of size = ', self size asString;		yourself.```After having defined this method, inspecting the expression `#(1 2 3 5) asOrderedCollection` shows the inspector with a new textual pane.A Roassal view can also be hooked, as follow:```OrderedCollection>>inspectorCanvas2	<inspectorPresentationOrder: 90 title: 'Visualization'>	| canvas shapes |	canvas := RSCanvas new.	shapes := (self collect: [ :obj | RSBox new model: obj; size: 20 ]) asGroup.	canvas addAll: shapes.	RSGridLayout on: shapes.		^ SpRoassal3InspectorPresenter new		canvas: canvas;		yourself```The default behavior of the Spec inspector is to show an evaluation pane. You can remove it by simply defining the method:```OrderedCollection>>inspectorCanvas2Context: aContext	aContext withoutEvaluator```This method follow the naming convention. You simple need to use the method name that define the visualization and add `Context:`.