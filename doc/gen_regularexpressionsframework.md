# Regular expressions framework## IntroductionA regular expression is a template specifying a class of strings. Aregular expression matcher is an tool that determines whether a stringbelongs to a class specified by a regular expression.  This is acommon task of a user input validation code, and the use of regularexpressions can GREATLY simplify and speed up development of suchcode.  As an example, here is how to verify that a string is a validhexadecimal number in Smalltalk notation, using this matcher package:	aString matchesRegex: '16r[[:xdigit:]]+'(Coding the same ``the hard way'' is an exercise to a curious reader).This matcher is offered to the Smalltalk community in hope it will beuseful. It is free in terms of money, and to a large extent--in termsof rights of use. Refer to `Boring Stuff' section for legalese.The 'What's new in this release' section describes the functionalityintroduced in 1.1 release.The `Syntax' section explains the recognized syntax of regularexpressions.The `Usage' section explains matcher capabilities that go beyond whatString>>matchesRegex: method offers.The `Implementation notes' sections says a few words about what isunder the hood.Happy hacking,--Vassili Bykov <vassili@objectpeople.com> <vassili@magma.ca>August 6, 1996April 4, 1999## What's newVERSION 1.3.1 (September 2008)1. Updated documentation of character classes, making clear the problems of locale - an area for future improvementVERSION 1.3 (September 2008)1. \w now matches underscore as well as alphanumerics, in line with most other regex libraries (and our documentation!).  2. \W rejects underscore as well as alphanumerics3. added tests for this at end of testSuite4. updated documentation and added note to old incorrect comments in version 1.1 belowVERSION 1.2.3 (November 2007)1. Regexs with ^ or $ applied to copy empty strings caused infinite loops, e.g. ('' copyWithRegex: '^.*$' matchesReplacedWith: 'foo'). Applied a similar correction to that from version 1.1c, to #copyStream:to:(replacingMatchesWith:|translatingMatchesUsing:).2. Extended RxParser testing to run each test for #copy:translatingMatchesUsing: as well as #search:.3. Corrected #testSuite test that a dot does not match a null, which was passing by luck with Smalltalk code in a literal array.4. Added test to end of test suite for fix 1 above.VERSION 1.2.2 (November 2006)There was no way to specify a backslash in a character set. Now [\\] is accepted.VERSION 1.2.1	(August 2006)1. Support for returning all ranges (startIndex to: stopIndex) matching a regex - #allRangesOfRegexMatches:, #matchingRangesIn:2. Added hint to usage documentation on how to get more information about matches when enumerating3. Syntax description of dot corrected: matches anything but NUL since 1.1aVERSION 1.2	(May 2006)Fixed case-insensitive search for character sets.VERSION 1.1c	(December 2004)Fixed the issue with #matchesOnStream:do: which caused infinite loops for matches that matched empty strings.VERSION 1.1b	(November 2001)Changes valueNowOrOnUnwindDo: to ensure:, plus incorporates some earlier fixes.VERSION 1.1a	(May 2001)1. Support for keeping track of multiple subexpressions.2. Dot (.) matches anything but NUL character, as it should per POSIX spec.3. Some bug fixes.VERSION 1.1	(October 1999)Regular expression syntax corrections and enhancements:1. Backslash escapes similar to those in Perl are allowed in patterns:	\w	any word constituent character (equivalent to [a-zA-Z0-9_]) *** underscore only since 1.3 ***	\W	any character but a word constituent (equivalent to [^a-xA-Z0-9_] *** underscore only since 1.3 ***	\d	a digit (same as [0-9])	\D	anything but a digit	\s 	a whitespace character	\S	anything but a whitespace character	\b	an empty string at a word boundary	\B	an empty string not at a word boundary	\<	an empty string at the beginning of a word	\>	an empty string at the end of a wordFor example, '\w+' is now a valid expression matching any word.2. The following backslash escapes are also allowed in character sets(between square brackets):	\w, \W, \d, \D, \s, and \S.3. The following grep(1)-compatible named character classes arerecognized in character sets as well:	[:alnum:]	[:alpha:]	[:cntrl:]	[:digit:]	[:graph:]	[:lower:]	[:print:]	[:punct:]	[:space:]	[:upper:]	[:xdigit:]For example, the following patterns are equivalent:	'[[:alnum:]_]+' '\w+'  '[\w]+' '[a-zA-Z0-9_]+' *** underscore only since 1.3 ***4. Some non-printable characters can be represented in regularexpressions using a common backslash notation:	\t	tab (Character tab)	\n	newline (Character lf)	\r	carriage return (Character cr)	\f	form feed (Character newPage)	\e	escape (Character esc)5. A dot is corectly interpreted as 'any character but a newline'instead of 'anything but whitespace'.6. Case-insensitive matching.  The easiest access to it are newmessages CharacterArray understands: #asRegexIgnoringCase, #matchesRegexIgnoringCase:, #prefixMatchesRegexIgnoringCase:.7. The matcher (an instance of RxMatcher, the result ofString>>asRegex) now provides a collection-like interface to matchesin a particular string or on a particular stream, as well assubstitution protocol. The interface includes the following messages:	matchesIn: aString	matchesIn: aString collect: aBlock	matchesIn: aString do: aBlock	matchesOnStream: aStream	matchesOnStream: aStream collect: aBlock	matchesOnStream: aStream do: aBlock	copy: aString translatingMatchesUsing: aBlock	copy: aString replacingMatchesWith: replacementString	copyStream: aStream to: writeStream translatingMatchesUsing: aBlock	copyStream: aStream to: writeStream replacingMatchesWith: aStringExamples:	'\w+' asRegex matchesIn: 'now is the time'returns an OrderedCollection containing four strings: 'now', 'is','the', and 'time'.	'\<t\w+' asRegexIgnoringCase		copy: 'now is the Time'		translatingMatchesUsing: [:match | match asUppercase]returns 'now is THE TIME' (the regular expression matches wordsbeginning with either an uppercase or a lowercase T).ACKNOWLEDGEMENTSSince the first release of the matcher, thanks to the input fromseveral fellow Smalltalkers, I became convinced a native Smalltalkregular expression matcher was worth the effort to keep it alive. Forthe contributions, suggestions, and bug reports that made this release possible, I want to thank:	Felix Hack	Peter Hatch	Alan Knight	Eliot Miranda	Thomas Muhr	Robb Shecter	David N. Smith	Francis Wolinskiand anyone whom I haven't yet met or heard from, but who agrees thishas not been a complete waste of time.--Vassili BykovOctober 3, 1999## Syntax[You can select and "print it' examples in this method. Just don'tforget to cancel the changes.]The simplest regular expression is a single character.  It matchesexactly that character. A sequence of characters matches a string withexactly the same sequence of characters:	'a' matchesRegex: 'a'				-- true	'foobar' matchesRegex: 'foobar'		-- true	'blorple' matchesRegex: 'foobar'		-- falseThe above paragraph introduced a primitive regular expression (acharacter), and an operator (sequencing). Operators are applied toregular expressions to produce more complex regular expressions.Sequencing (placing expressions one after another) as an operator is,in a certain sense, `invisible'--yet it is arguably the most common.A more `visible' operator is Kleene closure, more often simplyreferred to as `a star'.  A regular expression followed by an asteriskmatches any number (including 0) of matches of the originalexpression. For example:	'ab' matchesRegex: 'a*b'		 		-- true	'aaaaab' matchesRegex: 'a*b'	 	-- true	'b' matchesRegex: 'a*b'		 		-- true	'aac' matchesRegex: 'a*b'	 		-- false: b does not matchA star's precedence is higher than that of sequencing. A star appliesto the shortest possible subexpression that precedes it. For example,'ab*' means `a followed by zero or more occurrences of b', not `zeroor more occurrences of ab':	'abbb' matchesRegex: 'ab*'	 		-- true	'abab' matchesRegex: 'ab*'		 	-- falseTo actually make a regex matching `zero or more occurrences of ab',`ab' is enclosed in parentheses:	'abab' matchesRegex: '(ab)*'		 	-- true	'abcab' matchesRegex: '(ab)*'	 	-- false: c spoils the funTwo other operators similar to `*' are `+' and `?'. `+' (positiveclosure, or simply `plus') matches one or more occurrences of theoriginal expression. `?' (`optional') matches zero or one, but nevermore, occurrences.	'ac' matchesRegex: 'ab*c'	 		-- true	'ac' matchesRegex: 'ab+c'	 		-- false: need at least one b	'abbc' matchesRegex: 'ab+c'		 	-- true	'abbc' matchesRegex: 'ab?c'		 	-- false: too many b'sAs we have seen, characters `*', `+', `?', `(', and `)' have specialmeaning in regular expressions. If one of them is to be usedliterally, it should be quoted: preceded with a backslash. (Thus,backslash is also special character, and needs to be quoted for aliteral match--as well as any other special character describedfurther).	'ab*' matchesRegex: 'ab*'		 	-- false: star in the right string is special	'ab*' matchesRegex: 'ab\*'	 		-- true	'a\c' matchesRegex: 'a\\c'		 	-- trueThe last operator is `|' meaning `or'. It is placed between tworegular expressions, and the resulting expression matches if one ofthe expressions matches. It has the lowest possible precedence (lowerthan sequencing). For example, `ab*|ba*' means `a followed by anynumber of b's, or b followed by any number of a's':	'abb' matchesRegex: 'ab*|ba*'	 	-- true	'baa' matchesRegex: 'ab*|ba*'	 	-- true	'baab' matchesRegex: 'ab*|ba*'	 	-- falseA bit more complex example is the following expression, matching thename of any of the Lisp-style `car', `cdr', `caar', `cadr',... functions:	c(a|d)+rIt is possible to write an expression matching an empty string, forexample: `a|'.  However, it is an error to apply `*', `+', or `?' tosuch expression: `(a|)*' is an invalid expression.So far, we have used only characters as the 'smallest' components ofregular expressions. There are other, more `interesting', components.A character set is a string of characters enclosed in squarebrackets. It matches any single character if it appears between thebrackets. For example, `[01]' matches either `0' or `1':	'0' matchesRegex: '[01]'		 		-- true	'3' matchesRegex: '[01]'		 		-- false	'11' matchesRegex: '[01]'		 		-- false: a set matches only one characterUsing plus operator, we can build the following binary numberrecognizer:	'10010100' matchesRegex: '[01]+'	 	-- true	'10001210' matchesRegex: '[01]+'	 	-- falseIf the first character after the opening bracket is `^', the set isinverted: it matches any single character *not* appearing between thebrackets:	'0' matchesRegex: '[^01]'		  		-- false	'3' matchesRegex: '[^01]'		 		-- trueFor convenience, a set may include ranges: pairs of charactersseparated with `-'. This is equivalent to listing all charactersbetween them: `[0-9]' is the same as `[0123456789]'.Special characters within a set are `^', `-', and `]' that closes theset. Below are the examples of how to literally use them in a set:	[01^]		-- put the caret anywhere except the beginning	[01-]		-- put the dash as the last character	[]01]		-- put the closing bracket as the first character 	[^]01]			(thus, empty and universal sets cannot be specified)Regular expressions can also include the following backquote escapesto refer to popular classes of characters:	\w	any word constituent character (same as [a-zA-Z0-9_])	\W	any character but a word constituent	\d	a digit (same as [0-9])	\D	anything but a digit	\s 	a whitespace character (same as [:space:] below)	\S	anything but a whitespace characterThese escapes are also allowed in character classes: '[\w+-]' means'any character that is either a word constituent, or a plus, or aminus'.Character classes can also include the following grep(1)-compatibleelements to refer to:	[:alnum:]		any alphanumeric character (same as [a-zA-Z0-9])	[:alpha:]		any alphabetic character (same as [a-zA-Z])	[:cntrl:]		any control character. (any character with code < 32)	[:digit:]		any decimal digit (same as [0-9])	[:graph:]		any graphical character. (any character with code >= 32).	[:lower:]		any lowercase character (including non-ASCII lowercase characters)	[:print:]		any printable character. In this version, this is the same as [:graph:]	[:punct:]		any punctuation character:  . , ! ? ; : ' - ( ) ` and double quotes	[:space:]		any whitespace character (space, tab, CR, LF, null, form feed, Ctrl-Z, 16r2000-16r200B, 16r3000)	[:upper:]		any uppercase character (including non-ASCII uppercase characters)	[:xdigit:]		any hexadecimal character (same as [a-fA-F0-9]).Note that many of these are only as consistent or inconsistent on issuesof locale as the underlying Smalltalk implementation. Values shown hereare for VisualWorks 7.6.Note that these elements are components of the character classes,i.e. they have to be enclosed in an extra set of square brackets toform a valid regular expression.  For example, a non-empty string ofdigits would be represented as '[[:digit:]]+'.The above primitive expressions and operators are common to manyimplementations of regular expressions. The next primitive expressionis unique to this Smalltalk implementation.A sequence of characters between colons is treated as a unary selectorwhich is supposed to be understood by Characters. A character matchessuch an expression if it answers true to a message with thatselector. This allows a more readable and efficient way of specifyingcharacter classes. For example, `[0-9]' is equivalent to `:isDigit:',but the latter is more efficient. Analogously to character sets,character classes can be negated: `:^isDigit:' matches a Characterthat answers false to #isDigit, and is therefore equivalent to`[^0-9]'.As an example, so far we have seen the following equivalent ways towrite a regular expression that matches a non-empty string of digits:	'[0-9]+'	'\d+'	'[\d]+'	'[[:digit:]]+'	:isDigit:+'The last group of special primitive expressions includes: 	.	matching any character except a NULL; 	^	matching an empty string at the beginning of a line; 	$	matching an empty string at the end of a line.	\b	an empty string at a word boundary	\B	an empty string not at a word boundary	\<	an empty string at the beginning of a word	\>	an empty string at the end of a word	'axyzb' matchesRegex: 'a.+b'		-- true	'ax zb' matchesRegex: 'a.+b'			-- true (space is matched by `.')	'axzb' matchesRegex: 'a.+b'				-- true (carriage return is matched by `.')Again, the dot ., caret ^ and dollar $ characters are special and should be quotedto be matched literally.	EXAMPLESAs the introductions said, a great use for regular expressions is userinput validation. Following are a few examples of regular expressionsthat might be handy in checking input entered by the user in an inputfield. Try them out by entering something between the quotes andprint-iting. (Also, try to imagine Smalltalk code that each validationwould require if coded by hand).  Most example expressions could havebeen written in alternative ways.Checking if aString may represent a nonnegative integer number:	'' matchesRegex: ':isDigit:+'or	'' matchesRegex: '[0-9]+'or	'' matchesRegex: '\d+'Checking if aString may represent an integer number with an optionalsign in front:	'' matchesRegex: '(\+|-)?\d+'Checking if aString is a fixed-point number, with at least one digitis required after a dot:	'' matchesRegex: '(\+|-)?\d+(\.\d+)?'The same, but allow notation like `123.':	'' matchesRegex: '(\+|-)?\d+(\.\d*)?'Recognizer for a string that might be a name: one word with firstcapital letter, no blanks, no digits.  More traditional:	'' matchesRegex: '[A-Z][A-Za-z]*'more Smalltalkish:	'' matchesRegex: ':isUppercase::isAlphabetic:*'A date in format MMM DD, YYYY with any number of spaces in between, inXX century:	'' matchesRegex: '(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)[ ]+(\d\d?)[ ]*,[ ]*19(\d\d)'Note parentheses around some components of the expression above. As`Usage' section shows, they will allow us to obtain the actual stringsthat have matched them (i.e. month name, day number, and year number).For dessert, coming back to numbers: here is a recognizer for ageneral number format: anything like 999, or 999.999, or -999.999e+21.	'' matchesRegex: '(\+|-)?\d+(\.\d*)?((e|E)(\+|-)?\d+)?'## UsageThe preceding section covered the syntax of regular expressions. Itused the simplest possible interface to the matcher: sending #matchesRegex: message to the sample string, with regular expressionstring as the argument.  This section explains hairier ways of usingthe matcher.	PREFIX MATCHING AND CASE-INSENSITIVE MATCHINGA CharacterArray (an EsString in VA) also understands these messages:	#prefixMatchesRegex: regexString	#matchesRegexIgnoringCase: regexString	#prefixMatchesRegexIgnoringCase: regexString #prefixMatchesRegex: is just like #matchesRegex, except that the wholereceiver is not expected to match the regular expression passed as theargument; matching just a prefix of it is enough.  For example:	'abcde' matchesRegex: '(a|b)+'		-- false	'abcde' prefixMatchesRegex: '(a|b)+'	-- trueThe last two messages are case-insensitive versions of matching.	ENUMERATION INTERFACEAn application can be interested in all matches of a certain regularexpression within a String.  The matches are accessible using aprotocol modelled after the familiar Collection-like enumerationprotocol:	#regex: regexString matchesDo: aBlockEvaluates a one-argument <aBlock> for every match of the regularexpression within the receiver string.	#regex: regexString matchesCollect: aBlockEvaluates a one-argument <aBlock> for every match of the regularexpression within the receiver string. Collects results of evaluationsand anwers them as a SequenceableCollection.	#allRegexMatches: regexStringReturns a collection of all matches (substrings of the receiverstring) of the regular expression.  It is an equivalent of <aStringregex: regexString matchesCollect: [:each | each]>.	#allRangesOfRegexMatches: regexStringReturns a collection of all character ranges (startIndex to: stopIndex)that match the regular expression.	REPLACEMENT AND TRANSLATIONIt is possible to replace all matches of a regular expression with acertain string using the message:	#copyWithRegex: regexString matchesReplacedWith: aStringFor example:	'ab cd ab' copyWithRegex: '(a|b)+' matchesReplacedWith: 'foo'A more general substitution is match translation:	#copyWithRegex: regexString matchesTranslatedUsing: aBlockThis message evaluates a block passing it each match of the regularexpression in the receiver string and answers a copy of the receiverwith the block results spliced into it in place of the respectivematches.  For example:	'ab cd ab' copyWithRegex: '(a|b)+' matchesTranslatedUsing: [:each | each asUppercase]All messages of enumeration and replacement protocols perform acase-sensitive match.  Case-insensitive versions are not provided aspart of a CharacterArray protocol.  Instead, they are accessible usingthe lower-level matching interface.	LOWER-LEVEL INTERFACEInternally, #matchesRegex: works as follows:1. A fresh instance of RxParser is created, and the regular expressionstring is passed to it, yielding the expression's syntax tree.2. The syntax tree is passed as an initialization parameter to aninstance of RxMatcher. The instance sets up some data structure thatwill work as a recognizer for the regular expression described by thetree.3. The original string is passed to the matcher, and the matcherchecks for a match.	THE MATCHERIf you repeatedly match a number of strings against the same regularexpression using one of the messages defined in CharacterArray, theregular expression string is parsed and a matcher is created anew forevery match.  You can avoid this overhead by building a matcher forthe regular expression, and then reusing the matcher over and overagain. You can, for example, create a matcher at a class or instanceinitialization stage, and store it in a variable for future use.You can create a matcher using one of the following methods:	- Sending #forString:ignoreCase: message to RxMatcher class, withthe regular expression string and a Boolean indicating whether case isignored as arguments.	- Sending #forString: message.  It is equivalent to <... forString:regexString ignoreCase: false>.A more convenient way is using one of the two matcher-created messagesunderstood by CharacterArray.	- <regexString asRegex> is equivalent to <RxMatcher forString:regexString>.	- <regexString asRegexIgnoringCase> is equivalent to <RxMatcherforString: regexString ignoreCase: true>.Here are four examples of creating a matcher:	hexRecognizer := RxMatcher forString: '16r[0-9A-Fa-f]+'	hexRecognizer := RxMatcher forString: '16r[0-9A-Fa-f]+' ignoreCase: false	hexRecognizer := '16r[0-9A-Fa-f]+' asRegex	hexRecognizer := '16r[0-9A-F]+' asRegexIgnoringCase	MATCHINGThe matcher understands these messages (all of them return true toindicate successful match or search, and false otherwise):matches: aString	True if the whole target string (aString) matches.matchesPrefix: aString	True if some prefix of the string (not necessarily the whole	string) matches.search: aString	Search the string for the first occurrence of a matching	substring. (Note that the first two methods only try matching from	the very beginning of the string). Using the above example with a	matcher for `a+', this method would answer success given a string	`baaa', while the previous two would fail.matchesStream: aStreammatchesStreamPrefix: aStreamsearchStream: aStream	Respective analogs of the first three methods, taking input from a	stream instead of a string. The stream must be positionable and	peekable.All these methods answer a boolean indicating success. The matcheralso stores the outcome of the last match attempt and can report it:lastResult	Answers a Boolean -- the outcome of the most recent match	attempt. If no matches were attempted, the answer is unspecified.	SUBEXPRESSION MATCHESAfter a successful match attempt, you can query the specifics of whichpart of the original string has matched which part of the wholeexpression.A subexpression is a parenthesized part of a regular expression, orthe whole expression. When a regular expression is compiled, itssubexpressions are assigned indices starting from 1, depth-first,left-to-right. For example, `((ab)+(c|d))?ef' includes the followingsubexpressions with these indices:	1:	((ab)+(c|d))?ef	2:	(ab)+(c|d)	3:	ab	4:	c|dAfter a successful match, the matcher can report what part of theoriginal string matched what subexpression. It understandards thesemessages:subexpressionCount	Answers the total number of subexpressions: the highest value that	can be used as a subexpression index with this matcher. This value	is available immediately after initialization and never changes.subexpression: anIndex	An index must be a valid subexpression index, and this message	must be sent only after a successful match attempt. The method	answers a substring of the original string the corresponding	subexpression has matched to.subBeginning: anIndexsubEnd: anIndex	Answer positions within the original string or stream where the	match of a subexpression with the given index has started and	ended, respectively.This facility provides a convenient way of extracting parts of inputstrings of complex format. For example, the following piece of codeuses the 'MMM DD, YYYY' date format recognizer example from the`Syntax' section to convert a date to a three-element array with year,month, and day strings (you can select and evaluate it right here):	| matcher |	matcher := RxMatcher forString: '(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)[ ]+(:isDigit::isDigit:?)[ ]*,[ ]*(19|20)(:isDigit::isDigit:)'.	(matcher matches: 'Aug 6, 1996')		ifTrue: 			[Array 				with: (matcher subexpression: 5)				with: (matcher subexpression: 2)				with: (matcher subexpression: 3)]		ifFalse: ['no match'](should answer ` #('96' 'Aug' '6')').	ENUMERATION AND REPLACEMENTThe enumeration and replacement protocols exposed in CharacterArrayare actually implemented by the matcher.  The following messages areunderstood:	#matchesIn: aString	#matchesIn: aString do: aBlock	#matchesIn: aString collect: aBlock	#copy: aString replacingMatchesWith: replacementString	#copy: aString translatingMatchesUsing: aBlock	#matchingRangesIn: aString	#matchesOnStream: aStream	#matchesOnStream: aStream do: aBlock	#matchesOnStream: aStream collect: aBlock	#copy: sourceStream to: targetStream replacingMatchesWith: replacementString	#copy: sourceStream to: targetStream translatingMatchesWith: aBlockNote that in those methods that take a block, the block may refer to the rxMatcher itself, e.g. to collect information about the position the match occurred at, or thesubexpressions of the match. An example can be seen in #matchingRangesIn:	ERROR HANDLINGException signaling objects (Signals in VisualWorks, Exceptions in VisualAge) areaccessible through RxParser class protocol. To handle possible errors, usethe protocol described below to obtain the exception objects and use theprotocol of the native Smalltalk implementation to handle them.If a syntax error is detected while parsing expression,RxParser>>syntaxErrorSignal is raised/signaled.If an error is detected while building a matcher,RxParser>>compilationErrorSignal is raised/signaled.If an error is detected while matching (for example, if a bad selectorwas specified using `:<selector>:' syntax, or because of the matcher'sinternal error), RxParser>>matchErrorSignal is raisedRxParser>>regexErrorSignal is the parent of all three.  Since any ofthe three signals can be raised within a call to #matchesRegex:, it ishandy if you want to catch them all.  For example:VisualWorks:	RxParser regexErrorSignal		handle: [:ex | ex returnWith: nil]		do: ['abc' matchesRegex: '))garbage[']VisualAge:	['abc' matchesRegex: '))garbage[']		when: RxParser regexErrorSignal		do: [:signal | signal exitWith: nil]## Implementation notesVersion:		1.1	Released:		October 1999	Mail to:		Vassili Bykov <vassili@parcplace.com>, <v_bykov@yahoo.com>	Flames to:		/dev/null	WHAT IS ADDEDThe matcher includes classes in two categories:	VB-Regex-Syntax	VB-Regex-Matcherand a few CharacterArray methods in `VB-regex' protocol.  No systemclasses or methods are modified.	WHAT TO LOOK AT FIRSTString>>matchesRegex: -- in 90% cases this method is all you need toaccess the package.RxParser -- accepts a string or a stream of characters with a regularexpression, and produces a syntax tree corresponding to theexpression. The tree is made of instances of Rxs<whatever> classes.RxMatcher -- accepts a syntax tree of a regular expression built bythe parser and compiles it into a matcher: a structure made ofinstances of Rxm<whatever> classes. The RxMatcher instance can testwhether a string or a positionable stream of characters matches theoriginal regular expression, or search a string or a stream forsubstrings matching the expression. After a match is found, thematcher can report a specific string that matched the wholeexpression, or any parenthesized subexpression of it.All other classes support the above functionality and are used byRxParser, RxMatcher, or both.	CAVEATSThe matcher is similar in spirit, but NOT in the design--let alone thecode--to the original Henry Spencer's regular expressionimplementation in C.  The focus is on simplicity, not on efficiency.I didn't optimize or profile anything.  I may in future--or I may not:I do this in my spare time and I don't promise anything.The matcher passes H. Spencer's test suite (see 'test suite'protocol), with quite a few extra tests added, so chances are goodthere are not too many bugs.  But watch out anyway.	EXTENSIONS, FUTURE, ETC.With the existing separation between the parser, the syntax tree, andthe matcher, it is easy to extend the system with other matchers basedon other algorithms. In fact, I have a DFA-based matcher right now,but I don't feel it is good enough to include it here.  I might addautomata-based matchers later, but again I don't promise anything.	HOW TO REACH MEAs of today (December 20, 2000), you can contact me at<vassili@parcplace.com>. If this doesn't work, look aroundcomp.lang.smalltalk or comp.lang.lisp.  ## LicenseThe Regular Expression Matcher (``The Software'') is Copyright (C) 1996, 1999 Vassili Bykov.  It is provided to the Smalltalk community in hope it will be useful.1. This license applies to the package as a whole, as well as to any   component of it. By performing any of the activities described   below, you accept the terms of this agreement.2. The software is provided free of charge, and ``as is'', in hope   that it will be useful, with ABSOLUTELY NO WARRANTY. The entire   risk and all responsibility for the use of the software is with   you.  Under no circumstances the author may be held responsible for   loss of data, loss of profit, or any other damage resulting   directly or indirectly from the use of the software, even if the   damage is caused by defects in the software.3. You may use this software in any applications you build.4. You may distribute this software provided that the software   documentation and copyright notices are included and intact.5. You may create and distribute modified versions of the software,   such as ports to other Smalltalk dialects or derived work, provided   that:    a. any modified version is expressly marked as such and is not   misrepresented as the original software;    b. credit is given to the original software in the source code and   documentation of the derived work;    c. the copyright notice at the top of this document accompanies   copyright notices of any modified version.  ## API Documentation### Regex-Core#### ManifestRegexCoreSupport for regular expressions.##### Instance side##### Class sideManifestRegexCore class>>#manuallyResolvedDependenciesMethod has no comment.#### RegexCompilationErrorThis class represents compilation errors in regular expressions.##### Instance side##### Class side#### RegexErrorThis is a common superclass for errors in regular expressions.##### Instance side##### Class side#### RegexMatchingErrorThis class represents matching errors in regular expressions.##### Instance side##### Class side#### RegexSyntaxErrorThis class represents syntax errors in regular expressions.##### Instance sideRegexSyntaxError>>#positionreturn the parsing error locationRegexSyntaxError>>#position:Method has no comment.##### Class sideRegexSyntaxError class>>#signal:at:Method has no comment.#### RxCharSetParser-- Regular Expression Matcher v 1.1 (C) 1996, 1999 Vassili Bykov--I am a parser created to parse the insides of a character set ([...]) construct. I create and answer a collection of "elements", each being an instance of one of: RxsCharacter, RxsRange, or RxsPredicate.Instance Variables:	source <Stream>	open on whatever is inside the square brackets we have to parse.	lookahead	<Character>	The current lookahead character	elements	<Collection of: <RxsCharacter|RxsRange|RxsPredicate>> Parsing result##### Instance sideRxCharSetParser>>#addChar:Method has no comment.RxCharSetParser>>#addRangeFrom:to:Method has no comment.RxCharSetParser>>#initialize:Method has no comment.RxCharSetParser>>#match:Method has no comment.RxCharSetParser>>#parseMethod has no comment.RxCharSetParser>>#parseCharOrRangeMethod has no comment.RxCharSetParser>>#parseEscapeCharMethod has no comment.RxCharSetParser>>#parseNamedSetMethod has no comment.RxCharSetParser>>#parseStepMethod has no comment.##### Class sideRxCharSetParser class>>#on:Method has no comment.#### RxMatchOptimizer-- Regular Expression Matcher v 1.1 (C) 1996, 1999 Vassili Bykov--A match start optimizer, handy for searching a string. Takes a regex syntax tree and sets itself up so that prefix characters or matcher states that cannot start a match are later recognized with #canStartMatch:in: method.Used by RxMatcher, but can be used by other matchers (if implemented) as well.##### Instance sideRxMatchOptimizer>>#canStartMatch:in:Answer whether a match could commence at the given lookahead	character, or in the current state of <aMatcher>. True answered	by this method does not mean a match will definitly occur, while false	answered by this method *does* guarantee a match will never occur.RxMatchOptimizer>>#conditionTester #any condition is filtered at the higher level;	it cannot appear among the conditions here.RxMatchOptimizer>>#determineTestMethodAnswer a block closure that will work as a can-match predicate.	Answer nil if no viable optimization is possible (too many chars would	be able to start a match).RxMatchOptimizer>>#initialize:ignoreCase:Set `testMethod' variable to a can-match predicate block:	two-argument block which accepts a lookahead character	and a matcher (presumably built from aRegex) and answers 	a boolean indicating whether a match could start at the given	lookahead. RxMatchOptimizer>>#methodPredicateTesterMethod has no comment.RxMatchOptimizer>>#nonMethodPredicateTesterMethod has no comment.RxMatchOptimizer>>#nonPredicateTesterMethod has no comment.RxMatchOptimizer>>#nonPrefixTesterMethod has no comment.RxMatchOptimizer>>#optimizeSet:If a set is small, convert it to array to speed up lookup	(Array has no hashing overhead, beats Set on small number	of elements).RxMatchOptimizer>>#predicateTesterMethod has no comment.RxMatchOptimizer>>#prefixTesterMethod has no comment.RxMatchOptimizer>>#syntaxAnyAny special char is among the prefixes.RxMatchOptimizer>>#syntaxBeginningOfLineBeginning of line is among the prefixes.RxMatchOptimizer>>#syntaxBeginningOfWordBeginning of line is among the prefixes.RxMatchOptimizer>>#syntaxBranch:If the head piece of the branch is transparent (allows 0 matches),	we must recurse down the branch. Otherwise, just the head atom	is important.RxMatchOptimizer>>#syntaxCharSet:All these (or none of these) characters is the prefix.RxMatchOptimizer>>#syntaxCharacter:This character is the prefix, of one of them.RxMatchOptimizer>>#syntaxEndOfLineBeginning of line is among the prefixes.RxMatchOptimizer>>#syntaxEndOfWordMethod has no comment.RxMatchOptimizer>>#syntaxEpsilonEmpty string, terminate the recursion (do nothing).RxMatchOptimizer>>#syntaxLookaround:Method has no comment.RxMatchOptimizer>>#syntaxMessagePredicate:Method has no comment.RxMatchOptimizer>>#syntaxNonWordBoundaryMethod has no comment.RxMatchOptimizer>>#syntaxPiece:Pass on to the atom.RxMatchOptimizer>>#syntaxPredicate:Method has no comment.RxMatchOptimizer>>#syntaxRegex:All prefixes of the regex's branches should be combined.	Therefore, just recurse.RxMatchOptimizer>>#syntaxWordBoundaryMethod has no comment.##### Class side#### RxMatcher-- Regular Expression Matcher v 1.1 (C) 1996, 1999 Vassili Bykov--This is a recursive regex matcher. Not strikingly efficient, but simple. Also, keeps track of matched subexpressions.  The life cycle goes as follows:1. Initialization. Accepts a syntax tree (presumably produced by RxParser) and compiles it into a matcher built of other classes in this category.2. Matching. Accepts a stream or a string and returns a boolean indicating whether the whole stream or its prefix -- depending on the message sent -- matches the regex.3. Subexpression query. After a successful match, and before any other match, the matcher may be queried about the range of specific stream (string) positions that matched to certain parenthesized subexpressions of the original expression.Any number of queries may follow a successful match, and any number or matches may follow a successful initialization.Note that `matcher' is actually a sort of a misnomer. The actual matcher is a web of Rxm* instances built by RxMatcher during initialization. RxMatcher is just the interface facade of this network.  It is also a builder of it, and also provides a stream-like protocol to easily access the stream being matched.Instance variables:	matcher				<RxmLink> The entry point into the actual matcher.	stream				<Stream> The stream currently being matched against.	markerPositions		<Array of: Integer> Positions of markers' matches.	markerCount		<Integer> Number of markers.	lastResult 			<Boolean> Whether the latest match attempt succeeded or not.	lastChar			<Character | nil> character last seen in the matcher stream##### Instance sideRxMatcher>>#allocateMarkerAnswer an integer to use as an index of the next marker.RxMatcher>>#atBeginningOfLineMethod has no comment.RxMatcher>>#atBeginningOfWordMethod has no comment.RxMatcher>>#atEndMethod has no comment.RxMatcher>>#atEndOfLineMethod has no comment.RxMatcher>>#atEndOfWordMethod has no comment.RxMatcher>>#atWordBoundaryMethod has no comment.RxMatcher>>#buildFrom:Private - Entry point of matcher build process.RxMatcher>>#copy:replacingMatchesWith:Copy <aString>, except for the matches. Replace each match with <aString>.RxMatcher>>#copy:translatingMatchesUsing:Copy <aString>, except for the matches. For each match, evaluate <aBlock> passing the matched substring as the argument.  Expect the block to answer a String, and replace the match with the answer.RxMatcher>>#copyStream:to:replacingMatchesWith:Copy the contents of <aStream> on the <writeStream>, except for the matches. Replace each match with <aString>.RxMatcher>>#copyStream:to:translatingMatchesUsing:Copy the contents of <aStream> on the <writeStream>, except for the matches. For each match, evaluate <aBlock> passing the matched substring as the argument.  Expect the block to answer a String, and write the answer to <writeStream> in place of the match.RxMatcher>>#currentStateAnswer an opaque object that can later be used to restore the	matcher's state (for backtracking)RxMatcher>>#hookBranchOf:onto:Private - Recurse down the chain of regexes starting at	regexNode, compiling their branches and hooking their tails 	to the endMarker node.RxMatcher>>#initialize:ignoreCase:Compile thyself for the regex with the specified syntax tree.	See comment and `building' protocol in this class and 	#dispatchTo: methods in syntax tree components for details 	on double-dispatch building. 	The argument is supposedly a RxsRegex.RxMatcher>>#isWordChar:Answer whether the argument is a word constituent character:	alphanumeric or _.RxMatcher>>#lastCharMethod has no comment.RxMatcher>>#lastResultMethod has no comment.RxMatcher>>#makeOptional:Private - Wrap this matcher so that the result would match 0 or 1	occurrences of the matcher.RxMatcher>>#makePlus:Private - Wrap this matcher so that the result would match 1 and more	occurrences of the matcher.RxMatcher>>#makeQuantified:min:max:Perform recursive poor-man's transformation of the {<min>,<max>} quantifiers.RxMatcher>>#makeStar:Private - Wrap this matcher so that the result would match 0 and more	occurrences of the matcher.RxMatcher>>#markerPositionAt:add:Remember position of another instance of the given marker.RxMatcher>>#matches:Match against a string. Return true if the complete String matches.	If you want to search for occurrences anywhere in the String see #search:RxMatcher>>#matchesIn:Search aString repeatedly for the matches of the receiver.  Answer an OrderedCollection of all matches (substrings).RxMatcher>>#matchesIn:collect:Search aString repeatedly for the matches of the receiver.  Evaluate aBlock for each match passing the matched substring as the argument, collect evaluation results in an OrderedCollection, and return in. The following example shows how to use this message to split a string into words.RxMatcher>>#matchesIn:do:Search aString repeatedly for the matches of the receiver.	Evaluate aBlock for each match passing the matched substring	as the argument.RxMatcher>>#matchesOnStream:Method has no comment.RxMatcher>>#matchesOnStream:collect:Method has no comment.RxMatcher>>#matchesOnStream:do:Be extra careful about successful matches which consume no input.	After those, make sure to advance or finish if already at end.RxMatcher>>#matchesPrefix:Match against a string. Return true if a prefix matches.	If you want to match 		- the full string use #matches:		- anywhere in the string use #search:RxMatcher>>#matchesStream:Match thyself against a positionable stream.RxMatcher>>#matchesStreamPrefix:Match thyself against a positionable stream.RxMatcher>>#matchingRangesIn:Search aString repeatedly for the matches of the receiver.  Answer an OrderedCollection of ranges of each match (index of first character to: index of last character).RxMatcher>>#nextMethod has no comment.RxMatcher>>#notAtWordBoundaryMethod has no comment.RxMatcher>>#positionMethod has no comment.RxMatcher>>#proceedSearchingStream:Method has no comment.RxMatcher>>#restoreState:Method has no comment.RxMatcher>>#search:Search anywhere in the String for occurrence of something matching myself.	If you want to match the full String see #matches:	Answer a Boolean indicating success.RxMatcher>>#searchStream:Search the stream for occurrence of something matching myself.	After the search has occurred, stop positioned after the end of the	matched substring. Answer a Boolean indicating success.RxMatcher>>#split:indicesDo:Method has no comment.RxMatcher>>#subBeginning:Method has no comment.RxMatcher>>#subEnd:Method has no comment.RxMatcher>>#subexpression:Answer a string that matched the subexpression at the given index.	If there are multiple matches, answer the last one.	If there are no matches, answer nil. 	(NB: it used to answer an empty string but I think nil makes more sense).RxMatcher>>#subexpressionCountMethod has no comment.RxMatcher>>#subexpressions:Answer an array of all matches of the subexpression at the given index.	The answer is always an array; it is empty if there are no matches.RxMatcher>>#supportsSubexpressionsMethod has no comment.RxMatcher>>#syntaxAnyDouble dispatch from the syntax tree. 	Create a matcher for any non-null character.RxMatcher>>#syntaxBeginningOfLineDouble dispatch from the syntax tree. 	Create a matcher for beginning-of-line condition.RxMatcher>>#syntaxBeginningOfWordDouble dispatch from the syntax tree. 	Create a matcher for beginning-of-word condition.RxMatcher>>#syntaxBranch:Double dispatch from the syntax tree. 	Branch node is a link in a chain of concatenated pieces.	First build the matcher for the rest of the chain, then make 	it for the current piece and hook the rest to it.RxMatcher>>#syntaxCharSet:Double dispatch from the syntax tree. 	A character set is a few characters, and we either match any of them,	or match any that is not one of them.RxMatcher>>#syntaxCharacter:Double dispatch from the syntax tree. 	We get here when no merging characters into strings was possible.RxMatcher>>#syntaxEndOfLineDouble dispatch from the syntax tree. 	Create a matcher for end-of-line condition.RxMatcher>>#syntaxEndOfWordDouble dispatch from the syntax tree. 	Create a matcher for end-of-word condition.RxMatcher>>#syntaxEpsilonDouble dispatch from the syntax tree. Match empty string. This is unlikely	to happen in sane expressions, so we'll live without special epsilon-nodes.RxMatcher>>#syntaxLookaround:Double dispatch from the syntax tree. 	Special link can handle lookarounds (look ahead, positive and negative).RxMatcher>>#syntaxMessagePredicate:Double dispatch from the syntax tree. 	Special link can handle predicates.RxMatcher>>#syntaxNonWordBoundaryDouble dispatch from the syntax tree. 	Create a matcher for the word boundary condition.RxMatcher>>#syntaxPiece:Double dispatch from the syntax tree. 	Piece is an atom repeated a few times. Take care of a special	case when the atom is repeated just once.RxMatcher>>#syntaxPredicate:Double dispatch from the syntax tree. 	A character set is a few characters, and we either match any of them,	or match any that is not one of them.RxMatcher>>#syntaxRegex:Double dispatch from the syntax tree. 	Regex node is a chain of branches to be tried. Should compile this 	into a bundle of parallel branches, between two marker nodes.RxMatcher>>#syntaxWordBoundaryDouble dispatch from the syntax tree. 	Create a matcher for the word boundary condition.RxMatcher>>#tryMatchMatch thyself against the current stream.##### Class sideRxMatcher class>>#for:Create and answer a matcher that will match a regular expression	specified by the syntax tree of which `aRegex' is a root.RxMatcher class>>#for:ignoreCase:Create and answer a matcher that will match a regular expression	specified by the syntax tree of which `aRegex' is a root.RxMatcher class>>#forString:Create and answer a matcher that will match the regular expression	`aString'.RxMatcher class>>#forString:ignoreCase:Create and answer a matcher that will match the regular expression	`aString'.RxMatcher class>>#initializeRxMatcher initialize#### RxParser-- Regular Expression Matcher v 1.1 (C) 1996, 1999 Vassili Bykov--The regular expression parser. Translates a regular expression read from a stream into a parse tree. ('accessing' protocol). The tree can later be passed to a matcher initialization method.  All other classes in this category implement the tree. Refer to their comments for any details.Instance variables:	input		<Stream> A stream with the regular expression being parsed.	lookahead	<Character>##### Instance sideRxParser>>#atomAn atom is one of a lot of possibilities, see below.RxParser>>#branch<branch> ::= e | <piece> <branch>RxParser>>#characterSetMatch a range of characters: something between `[' and `]'.	Opening bracked has already been seen, and closing should	not be consumed as well. Set spec is as usual for	sets in regexes.RxParser>>#characterSetFrom:<setSpec> is what goes between the brackets in a charset regex	(a String). Make a string containing all characters the spec specifies.	Spec is never empty.RxParser>>#ifSpecial:then:If the character is such that it defines a special node when follows a $\,	then create that node and evaluate aBlock with the node as the parameter.	Otherwise just return.RxParser>>#inputUpTo:errorMessage:Accumulate input stream until <aCharacter> is encountered	and answer the accumulated chars as String, not including	<aCharacter>. Signal error if end of stream is encountered,	passing <aString> as the error description.RxParser>>#inputUpTo:nestedOn:errorMessage:Accumulate input stream until <aCharacter> is encountered	and answer the accumulated chars as String, not including	<aCharacter>. Signal error if end of stream is encountered,	passing <aString> as the error description.RxParser>>#inputUpToAny:errorMessage:Accumulate input stream until any character from <aDelimiterString> is encountered	and answer the accumulated chars as String, not including the matched characters from the	<aDelimiterString>. Signal error if end of stream is encountered,	passing <aString> as the error description.RxParser>>#lookAroundParse a lookaround expression after: (?<lookround>) 	<lookround> ::= !<regex> | =<regex>RxParser>>#match:<aCharacter> MUST match the current lookeahead.	If this is the case, advance the input. Otherwise, blow up.RxParser>>#messagePredicateMatch a message predicate specification: a selector (presumably	understood by a Character) enclosed in :'s .RxParser>>#nextAdvance the input storing the just read character	as the lookahead.RxParser>>#parse:Parse input from a string <aString>.	On success, answers an RxsRegex -- parse tree root.	On error, raises `RxParser syntaxErrorSignal' with the current	input stream position as the parameter.RxParser>>#parseStream:Parse an input from a character stream <aStream>.	On success, answers an RxsRegex -- parse tree root.	On error, raises `RxParser syntaxErrorSignal' with the current	input stream position as the parameter.RxParser>>#piece<piece> ::= <atom> | <atom>* | <atom>+ | <atom>? | <atom>{<number>,<number>}RxParser>>#quantifiedAtom:Parse a quanitifer expression which can have one of the following forms		{<min>,<max>}    match <min> to <max> occurrences		{<minmax>}       which is the same as with repeated limits: {<number>,<number>}		{<min>,}         match at least <min> occurrences		{,<max>}         match maximally <max> occurrences, which is the same as {0,<max>}RxParser>>#regex<regex> ::= e | <branch> `|' <regex>RxParser>>#signalNullableClosureParserErrorMethod has no comment.RxParser>>#signalParseErrorMethod has no comment.RxParser>>#signalParseError:Method has no comment.##### Class sideRxParser class>>#doHandlingMessageNotUnderstood:MNU should be trapped and resignaled as a match error in a few places in the matcher.	This method factors out this dialect-dependent code to make porting easier.RxParser class>>#initializeself initializeRxParser class>>#initializeBackslashConstantsself initializeBackslashConstantsRxParser class>>#initializeBackslashSpecialsKeys are characters that normally follow a \, the values are	associations of classes and initialization selectors on the instance side	of the classes.RxParser class>>#parse:Parse the argument and return the result (the parse tree).	In case of a syntax error, the corresponding exception is signaled.RxParser class>>#preferredMatcherClassThe matcher to use. For now just one is available, but in	principle this determines the matchers built implicitly,	such as by String>>asRegex, or String>>matchesRegex:.	This might seem a bit strange place for this preference, but	Parser is still more or less `central' thing in the whole package.RxParser class>>#safelyParse:Parse the argument and return the result (the parse tree).	In case of a syntax error, return nil.	Exception handling here is dialect-dependent.RxParser class>>#signalCompilationException:Method has no comment.RxParser class>>#signalMatchException:Method has no comment.RxParser class>>#signalSyntaxException:Method has no comment.RxParser class>>#signalSyntaxException:at:Method has no comment.#### RxmBranch-- Regular Expression Matcher v 1.1 (C) 1996, 1999 Vassili Bykov--This is a branch of a matching process. Either `next' chain should match, or `alternative', if not nil, should match. Since this is also used to build loopbacks to match repetitions, `loopback' variable indicates whether the instance is a loopback: it affects the matcher-building operations (which of the paths through the branch is to consider as the primary when we have to find the "tail" of a matcher construct).Instance variables	alternative		<RxmLink> to match if `next' fails to match.	loopback		<Boolean>##### Instance sideRxmBranch>>#alternative:See class comment for instance variable description.RxmBranch>>#beLoopbackSee class comment for instance variable description.RxmBranch>>#initializeSee class comment for instance variable description.RxmBranch>>#matchAgainst:Match the longest match of `next' or `alternative'. Fail the alternative if the alternative is nil.RxmBranch>>#pointTailTo:See superclass for explanations.RxmBranch>>#terminateWith:See superclass for explanations.##### Class side#### RxmLink-- Regular Expression Matcher v 1.1 (C) 1996, 1999 Vassili Bykov--A matcher is built of a number of links interconnected into some intricate structure. Regardless of fancy stuff, any link (except for the terminator) has the next one. Any link can match against a stream of characters, recursively propagating the match to the next link. Any link supports a number of matcher-building messages. This superclass does all of the above. The class is not necessarily abstract. It may double as an empty string matcher: it recursively propagates the match to the next link, thus always matching nothing successfully.Principal method:	matchAgainst: aMatcher		Any subclass will reimplement this to test the state of the matcher, most		probably reading one or more characters from the matcher's stream, and		either decide it has matched and answer true, leaving matcher stream		positioned at the end of match, or answer false and restore the matcher		stream position to whatever it was before the matching attempt.Instance variables:	next		<RxmLink | RxmTerminator> The next link in the structure.##### Instance sideRxmLink>>#matchAgainst:If a link does not match the contents of the matcher's stream,	answer false. Otherwise, let the next matcher in the chain match.RxmLink>>#nextMethod has no comment.RxmLink>>#next:Set the next link, either an RxmLink or an RxmTerminator.RxmLink>>#pointTailTo:Propagate this message along the chain of links.	Point `next' reference of the last link to <anRxmLink>.	If the chain is already terminated, blow up.RxmLink>>#postCopyMethod has no comment.RxmLink>>#terminateWith:Propagate this message along the chain of links, and	make aTerminator the `next' link of the last link in the chain.	If the chain is already reminated with the same terminator, 	do not blow up.##### Class side#### RxmLookahaedInstance holds onto a lookead which matches but does not consume anything.Instance variables:	predicate		<RxmLink>##### Instance sideRxmLookahaed>>#initializeMethod has no comment.RxmLookahaed>>#lookaheadMethod has no comment.RxmLookahaed>>#lookahead:Method has no comment.RxmLookahaed>>#matchAgainst:Match if the predicate block evaluates to true when given the	current stream character as the argument.RxmLookahaed>>#terminateWith:Method has no comment.##### Class sideRxmLookahaed class>>#with:Method has no comment.#### RxmMarker-- Regular Expression Matcher v 1.1 (C) 1996, 1999 Vassili Bykov--A marker is used to remember positions of match of certain points of a regular expression. The marker receives an identifying key from the Matcher and uses that key to report positions of successful matches to the Matcher.Instance variables:	index	<Object> Something that makes sense for the Matcher. Received from the latter during initalization and later passed to it to identify the receiver.##### Instance sideRxmMarker>>#index:An index is a key that makes sense for the matcher.	This key can be passed to marker position getters and	setters to access position for this marker in the current	matching session.RxmMarker>>#matchAgainst:If the rest of the link chain matches successfully, report the	position of the stream *before* the match started to the matcher.##### Class side#### RxmPredicate-- Regular Expression Matcher v 1.1 (C) 1996, 1999 Vassili Bykov--Instance holds onto a one-argument block and matches exactly one character if the block evaluates to true when passed the character as the argument.Instance variables:	predicate		<BlockClosure>##### Instance sideRxmPredicate>>#bePerform:Match any single character that answers true  to this message.RxmPredicate>>#bePerformNot:Match any single character that answers false to this message.RxmPredicate>>#matchAgainst:Match if the predicate block evaluates to true when given the	current stream character as the argument.RxmPredicate>>#predicate:This link will match any single character for which <aBlock>	evaluates to true.##### Class sideRxmPredicate class>>#with:Method has no comment.#### RxmSpecial-- Regular Expression Matcher v 1.1 (C) 1996, 1999 Vassili Bykov--A special node that matches a specific matcher state rather than any input character.The state is either at-beginning-of-line or at-end-of-line.##### Instance sideRxmSpecial>>#beBeginningOfLineMethod has no comment.RxmSpecial>>#beBeginningOfWordMethod has no comment.RxmSpecial>>#beEndOfLineMethod has no comment.RxmSpecial>>#beEndOfWordMethod has no comment.RxmSpecial>>#beNotWordBoundaryMethod has no comment.RxmSpecial>>#beWordBoundaryMethod has no comment.RxmSpecial>>#matchAgainst:Match without consuming any input, if the matcher is	in appropriate state.##### Class side#### RxmSubstring-- Regular Expression Matcher v 1.1 (C) 1996, 1999 Vassili Bykov--Instance holds onto a string and matches exactly this string, and exactly once.Instance variables:	string 	<String>##### Instance sideRxmSubstring>>#beCaseInsensitiveMethod has no comment.RxmSubstring>>#beCaseSensitiveMethod has no comment.RxmSubstring>>#character:ignoreCase:Match exactly this character.RxmSubstring>>#initializeMethod has no comment.RxmSubstring>>#matchAgainst:Match if my sample stream is exactly the current prefix	of the matcher stream's contents.RxmSubstring>>#sampleStreamMethod has no comment.RxmSubstring>>#substring:ignoreCase:Match exactly this string.##### Class side#### RxmTerminator-- Regular Expression Matcher v 1.1 (C) 1996, 1999 Vassili Bykov--Instances of this class are used to terminate matcher's chains. When a match reaches this (an instance receives #matchAgainst: message), the match is considered to succeed. Instances also support building protocol of RxmLinks, with some restrictions.##### Instance sideRxmTerminator>>#matchAgainst:If got here, the match is successful.RxmTerminator>>#pointTailTo:Branch tails are never redirected by the build algorithm.	Healthy terminators should never receive this.RxmTerminator>>#terminateWith:Branch terminators are never supposed to change.	Make sure this is the case.##### Class side#### RxsBranch-- Regular Expression Matcher v 1.1 (C) 1996, 1999 Vassili Bykov--A Branch is a Piece followed by a Branch or an empty string.Instance variables:	piece		<RxsPiece>	branch		<RxsBranch|RxsEpsilon>##### Instance sideRxsBranch>>#branchMethod has no comment.RxsBranch>>#dispatchTo:Inform the matcher of the kind of the node, and it	will do whatever it has to.RxsBranch>>#initializePiece:branch:See class comment for instance variables description.RxsBranch>>#isNullableMethod has no comment.RxsBranch>>#pieceMethod has no comment.RxsBranch>>#tryMergingInto:Concatenation of a few simple characters can be optimized	to be a plain substring match. Answer the node to resume	syntax tree traversal at. Epsilon node used to terminate the branch	will implement this to answer nil, thus indicating that the branch	has ended.##### Class side#### RxsCharSet-- Regular Expression Matcher v 1.1 (C) 1996, 1999 Vassili Bykov--A character set corresponds to a [...] construct in the regular expression.Instance variables:	elements	<OrderedCollection> An element can be one of: RxsCharacter, RxsRange, or RxsPredicate.	negated		<Boolean>##### Instance sideRxsCharSet>>#dispatchTo:Inform the matcher of the kind of the node, and it	will do whatever it has to.RxsCharSet>>#enumerablePartPredicateIgnoringCase:Method has no comment.RxsCharSet>>#enumerableSetIgnoringCase:Answer a collection of characters that make up the portion of me	that can be enumerated.RxsCharSet>>#hasPredicatesMethod has no comment.RxsCharSet>>#initializeElements:negated:See class comment for instance variables description.RxsCharSet>>#isEnumerableMethod has no comment.RxsCharSet>>#isNegatedMethod has no comment.RxsCharSet>>#optimalSetIgnoringCase:Assuming the client with search the `set' using #includes:,	answer a collection with the contents of `set', of the class	that will provide the fastest lookup. Strings are faster than	Sets for short strings.RxsCharSet>>#predicateIgnoringCase:Method has no comment.RxsCharSet>>#predicatePartPredicateAnswer a predicate that tests all of my elements that cannot be	enumerated.RxsCharSet>>#predicatesMethod has no comment.##### Class side#### RxsCharacter-- Regular Expression Matcher v 1.1 (C) 1996, 1999 Vassili Bykov--A character is a literal character that appears either in the expression itself or in a character set within an expression.Instance variables:	character		<Character>##### Instance sideRxsCharacter>>#characterMethod has no comment.RxsCharacter>>#dispatchTo:Inform the matcher of the kind of the node, and it	will do whatever it has to.RxsCharacter>>#enumerateTo:ignoringCase:Method has no comment.RxsCharacter>>#initializeCharacter:See class comment for instance variable description.RxsCharacter>>#isAtomicA character is always atomic.RxsCharacter>>#isEnumerableMethod has no comment.##### Class sideRxsCharacter class>>#with:Method has no comment.#### RxsContextCondition-- Regular Expression Matcher v 1.1 (C) 1996, 1999 Vassili Bykov--One of a few special nodes more often representing special state of the match rather than a predicate on a character.  The ugly exception is the #any condition which *is* a predicate on a character.Instance variables:	kind		<Selector>##### Instance sideRxsContextCondition>>#beAnyMatches anything but a newline.RxsContextCondition>>#beBeginningOfLineMatches empty string at the beginning of a line.RxsContextCondition>>#beBeginningOfWordMatches empty string at the beginning of a word.RxsContextCondition>>#beEndOfLineMatches empty string at the end of a line.RxsContextCondition>>#beEndOfWordMatches empty string at the end of a word.RxsContextCondition>>#beNonWordBoundaryAnalog of \B.RxsContextCondition>>#beWordBoundaryAnalog of \w (alphanumeric plus _).RxsContextCondition>>#dispatchTo:Method has no comment.RxsContextCondition>>#isNullableMethod has no comment.##### Class side#### RxsEpsilon-- Regular Expression Matcher v 1.1 (C) 1996, 1999 Vassili Bykov--This is an empty string.  It terminates some of the recursive constructs.##### Instance sideRxsEpsilon>>#dispatchTo:Inform the matcher of the kind of the node, and it	will do whatever it has to.RxsEpsilon>>#isNullableSee comment in the superclass.##### Class side#### RxsLookaroundI lookaround is used for lookaheads and lookbehinds. They are used to check if the input matches a certain subexpression without consuming any characters (e.g. not advancing the match position).Lookarounds can be positive or negative. If they are positive the condition fails if the subexpression fails, if they are negative it is inverse.##### Instance sideRxsLookaround>>#beNegativeMethod has no comment.RxsLookaround>>#bePositiveMethod has no comment.RxsLookaround>>#dispatchTo:Inform the matcher of the kind of the node, and it	will do whatever it has to.RxsLookaround>>#initializePiece:Method has no comment.RxsLookaround>>#pieceMethod has no comment.##### Class sideRxsLookaround class>>#with:Method has no comment.#### RxsMessagePredicate-- Regular Expression Matcher v 1.1 (C) 1996, 1999 Vassili Bykov--A message predicate represents a condition on a character that is tested (at the match time) by sending a unary message to the character expecting a Boolean answer.Instance variables:	selector		<Symbol>##### Instance sideRxsMessagePredicate>>#dispatchTo:Inform the matcher of the kind of the node, and it	will do whatever it has to.RxsMessagePredicate>>#initializeSelector:The selector must be a one-argument message understood by Character.RxsMessagePredicate>>#initializeSelector:negated:The selector must be a one-argument message understood by Character.RxsMessagePredicate>>#negatedMethod has no comment.RxsMessagePredicate>>#selectorMethod has no comment.##### Class side#### RxsNode-- Regular Expression Matcher v 1.1 (C) 1996, 1999 Vassili Bykov--A generic syntax tree node, provides some common responses to the standard tests, as well as tree structure printing -- handy for debugging.##### Instance sideRxsNode>>#indentCharacterNormally, #printOn:withIndent: method in subclasses	print several characters returned by this method to indicate	the tree structure.RxsNode>>#isAtomicAnswer whether the node is atomic, i.e. matches exactly one 	constant predefined normal character.  A matcher may decide to 	optimize matching of a sequence of atomic nodes by glueing them 	together in a string.RxsNode>>#isNullableTrue if the node can match an empty sequence of characters.##### Class side#### RxsPiece-- Regular Expression Matcher v 1.1 (C) 1996, 1999 Vassili Bykov--A piece is an atom, possibly optional or repeated a number of times.Instance variables:	atom	<RxsCharacter|RxsCharSet|RxsPredicate|RxsRegex|RxsSpecial>	min		<Integer>	max		<Integer|nil> nil means infinity##### Instance sideRxsPiece>>#atomMethod has no comment.RxsPiece>>#characterIf this node is atomic, answer the character it	represents. It is the caller's responsibility to make sure this	node is indeed atomic before using this.RxsPiece>>#dispatchTo:Inform the matcher of the kind of the node, and it	will do whatever it has to.RxsPiece>>#initializeAtom:This piece is exactly one occurrence of the specified RxsAtom.RxsPiece>>#initializeAtom:min:max:This piece is from <minOccurrences> to <maxOccurrences> 	occurrences of the specified RxsAtom.RxsPiece>>#initializeOptionalAtom:This piece is 0 or 1 occurrences of the specified RxsAtom.RxsPiece>>#initializePlusAtom:This piece is one or more occurrences of the specified RxsAtom.RxsPiece>>#initializeStarAtom:This piece is any number of occurrences of the atom.RxsPiece>>#isAtomicA piece is atomic if only it contains exactly one atom	which is atomic (sic).RxsPiece>>#isNullableA piece is nullable if it allows 0 matches. 	This is often handy to know for optimization.RxsPiece>>#isOptionalMethod has no comment.RxsPiece>>#isPlusMethod has no comment.RxsPiece>>#isSingularA piece with a range is 1 to 1 needs can be compiled	as a simple match.RxsPiece>>#isStarMethod has no comment.RxsPiece>>#maxThe value answered may be nil, indicating infinity.RxsPiece>>#minMethod has no comment.##### Class side#### RxsPredicate-- Regular Expression Matcher v 1.1 (C) 1996, 1999 Vassili Bykov--This represents a character that satisfies a certain predicate.Instance Variables:	predicate	<BlockClosure>	A one-argument block. If it evaluates to the value defined by <negated> when it is passed a character, the predicate is considered to match.	negation	<BlockClosure>	A one-argument block that is a negation of <predicate>.##### Instance sideRxsPredicate>>#beAlphaNumericMethod has no comment.RxsPredicate>>#beAlphabeticMethod has no comment.RxsPredicate>>#beBackslashMethod has no comment.RxsPredicate>>#beControlMethod has no comment.RxsPredicate>>#beDigitMethod has no comment.RxsPredicate>>#beGraphicsMethod has no comment.RxsPredicate>>#beHexDigitMethod has no comment.RxsPredicate>>#beLowercaseMethod has no comment.RxsPredicate>>#beNotDigitMethod has no comment.RxsPredicate>>#beNotSpaceMethod has no comment.RxsPredicate>>#beNotWordConstituentMethod has no comment.RxsPredicate>>#bePrintableMethod has no comment.RxsPredicate>>#bePunctuationMethod has no comment.RxsPredicate>>#beSpaceMethod has no comment.RxsPredicate>>#beUppercaseMethod has no comment.RxsPredicate>>#beWordConstituentMethod has no comment.RxsPredicate>>#dispatchTo:Method has no comment.RxsPredicate>>#isEnumerableMethod has no comment.RxsPredicate>>#negateMethod has no comment.RxsPredicate>>#negatedMethod has no comment.RxsPredicate>>#predicateMethod has no comment.RxsPredicate>>#predicateNegationMethod has no comment.RxsPredicate>>#value:Method has no comment.##### Class sideRxsPredicate class>>#forEscapedLetter:Method has no comment.RxsPredicate class>>#forNamedClass:Method has no comment.RxsPredicate class>>#initializeself initializeRxsPredicate class>>#initializeEscapedLetterSelectorsself initializeEscapedLetterSelectorsRxsPredicate class>>#initializeNamedClassSelectorsself initializeNamedClassSelectors#### RxsRange-- Regular Expression Matcher v 1.1 (C) 1996, 1999 Vassili Bykov--I represent a range of characters as appear in character classes such as	[a-ZA-Z0-9].I appear in a syntax tree only as an element of RxsCharSet.Instance Variables:	first	<Character>	last	<Character>##### Instance sideRxsRange>>#enumerateTo:ignoringCase:Add all of the elements I represent to the collection.RxsRange>>#initializeFirst:last:Method has no comment.RxsRange>>#isEnumerableMethod has no comment.##### Class sideRxsRange class>>#from:to:Method has no comment.#### RxsRegex-- Regular Expression Matcher v 1.1 (C) 1996, 1999 Vassili Bykov--The body of a parenthesized thing, or a top-level expression, also an atom.  Instance variables:	branch		<RxsBranch>	regex		<RxsRegex | RxsEpsilon>##### Instance sideRxsRegex>>#branchMethod has no comment.RxsRegex>>#dispatchTo:Inform the matcher of the kind of the node, and it	will do whatever it has to.RxsRegex>>#initializeBranch:regex:See class comment for instance variable description.RxsRegex>>#isNullableMethod has no comment.RxsRegex>>#regexMethod has no comment.##### Class side### Regex-Core-Tests#### RxExtensionsTestUnit tests for extensions done by Regex package##### Instance sideRxExtensionsTest>>#testSplitJoinBoundaryCasesEmpty splitter, joiner or sequence.RxExtensionsTest>>#testSplitStringOnRegexMethod has no comment.##### Class side#### RxMatcherTestThis class provides tests for the regular expression matcher.##### Instance sideRxMatcherTest>>#compileRegex:Compile the regex and answer the matcher, or answer nil if compilation fails.RxMatcherTest>>#henryReadmeMethod has no comment.RxMatcherTest>>#matcherClassMethod has no comment.RxMatcherTest>>#runMatcher:with:expect:withSubexpressions:Method has no comment.RxMatcherTest>>#runRegex:Run a clause anArray against a set of tests. Each clause is an array with a regex source string followed by sequence of 3-tuples. Each three-element group is one test to try against the regex, and includes: 1) test string; 2) expected result; 3) expected subexpression as an array of (index, substring), or nil.RxMatcherTest>>#testCaseInsensitiveMethod has no comment.RxMatcherTest>>#testCaseSensitiveMethod has no comment.RxMatcherTest>>#testCopyReplacingMatchesSee that the match context is preserved while copying stuff between matches:RxMatcherTest>>#testCopyTranslatingMatchesMethod has no comment.RxMatcherTest>>#testEmptyStringAtBeginningOfLineMethod has no comment.RxMatcherTest>>#testEmptyStringAtBeginningOfWordMethod has no comment.RxMatcherTest>>#testEmptyStringAtEndOfLineMethod has no comment.RxMatcherTest>>#testEmptyStringAtEndOfWordMethod has no comment.RxMatcherTest>>#testEmptyStringAtWordBoundaryMethod has no comment.RxMatcherTest>>#testEmptyStringNotAtWordBoundaryMethod has no comment.RxMatcherTest>>#testHenry001Method has no comment.RxMatcherTest>>#testHenry002Method has no comment.RxMatcherTest>>#testHenry003Method has no comment.RxMatcherTest>>#testHenry004Method has no comment.RxMatcherTest>>#testHenry005Method has no comment.RxMatcherTest>>#testHenry006Method has no comment.RxMatcherTest>>#testHenry007Method has no comment.RxMatcherTest>>#testHenry008Method has no comment.RxMatcherTest>>#testHenry009Method has no comment.RxMatcherTest>>#testHenry010Method has no comment.RxMatcherTest>>#testHenry011Method has no comment.RxMatcherTest>>#testHenry012Need to get creative to include the null character...RxMatcherTest>>#testHenry013Method has no comment.RxMatcherTest>>#testHenry014Method has no comment.RxMatcherTest>>#testHenry015Method has no comment.RxMatcherTest>>#testHenry016Method has no comment.RxMatcherTest>>#testHenry017Method has no comment.RxMatcherTest>>#testHenry018Method has no comment.RxMatcherTest>>#testHenry019Method has no comment.RxMatcherTest>>#testHenry020Method has no comment.RxMatcherTest>>#testHenry021Method has no comment.RxMatcherTest>>#testHenry022Method has no comment.RxMatcherTest>>#testHenry023Method has no comment.RxMatcherTest>>#testHenry024Method has no comment.RxMatcherTest>>#testHenry025Method has no comment.RxMatcherTest>>#testHenry026Method has no comment.RxMatcherTest>>#testHenry027Method has no comment.RxMatcherTest>>#testHenry028Method has no comment.RxMatcherTest>>#testHenry029Method has no comment.RxMatcherTest>>#testHenry030Method has no comment.RxMatcherTest>>#testHenry031Method has no comment.RxMatcherTest>>#testHenry032Method has no comment.RxMatcherTest>>#testHenry033Method has no comment.RxMatcherTest>>#testHenry034Method has no comment.RxMatcherTest>>#testHenry035Method has no comment.RxMatcherTest>>#testHenry036Method has no comment.RxMatcherTest>>#testHenry037Method has no comment.RxMatcherTest>>#testHenry038Method has no comment.RxMatcherTest>>#testHenry039Method has no comment.RxMatcherTest>>#testHenry040Method has no comment.RxMatcherTest>>#testHenry041Method has no comment.RxMatcherTest>>#testHenry042Method has no comment.RxMatcherTest>>#testHenry043Method has no comment.RxMatcherTest>>#testHenry044Method has no comment.RxMatcherTest>>#testHenry045Method has no comment.RxMatcherTest>>#testHenry046Method has no comment.RxMatcherTest>>#testHenry047Method has no comment.RxMatcherTest>>#testHenry048Method has no comment.RxMatcherTest>>#testHenry049Method has no comment.RxMatcherTest>>#testHenry050Method has no comment.RxMatcherTest>>#testHenry051Method has no comment.RxMatcherTest>>#testHenry052Method has no comment.RxMatcherTest>>#testHenry053Method has no comment.RxMatcherTest>>#testHenry054Method has no comment.RxMatcherTest>>#testHenry055Method has no comment.RxMatcherTest>>#testHenry056Method has no comment.RxMatcherTest>>#testHenry057Method has no comment.RxMatcherTest>>#testHenry058Method has no comment.RxMatcherTest>>#testHenry059Method has no comment.RxMatcherTest>>#testHenry060Method has no comment.RxMatcherTest>>#testHenry061Method has no comment.RxMatcherTest>>#testHenry062Method has no comment.RxMatcherTest>>#testHenry063Method has no comment.RxMatcherTest>>#testHenry064Method has no comment.RxMatcherTest>>#testHenry065Method has no comment.RxMatcherTest>>#testHenry066Method has no comment.RxMatcherTest>>#testHenry067Method has no comment.RxMatcherTest>>#testHenry068Method has no comment.RxMatcherTest>>#testHenry069Method has no comment.RxMatcherTest>>#testHenry070Method has no comment.RxMatcherTest>>#testHenry071Method has no comment.RxMatcherTest>>#testHenry072Method has no comment.RxMatcherTest>>#testHenry073Method has no comment.RxMatcherTest>>#testHenry074Method has no comment.RxMatcherTest>>#testHenry075Method has no comment.RxMatcherTest>>#testHenry076Method has no comment.RxMatcherTest>>#testHenry077Method has no comment.RxMatcherTest>>#testHenry078Method has no comment.RxMatcherTest>>#testHenry079Method has no comment.RxMatcherTest>>#testHenry080Method has no comment.RxMatcherTest>>#testHenry081Method has no comment.RxMatcherTest>>#testHenry082Method has no comment.RxMatcherTest>>#testHenry083Method has no comment.RxMatcherTest>>#testHenry084Method has no comment.RxMatcherTest>>#testHenry085Method has no comment.RxMatcherTest>>#testHenry086Method has no comment.RxMatcherTest>>#testHenry087Method has no comment.RxMatcherTest>>#testHenry088Method has no comment.RxMatcherTest>>#testHenry089Method has no comment.RxMatcherTest>>#testHenry090Method has no comment.RxMatcherTest>>#testHenry091Method has no comment.RxMatcherTest>>#testHenry092Method has no comment.RxMatcherTest>>#testHenry093Method has no comment.RxMatcherTest>>#testHenry094Method has no comment.RxMatcherTest>>#testHenry095Method has no comment.RxMatcherTest>>#testHenry096Method has no comment.RxMatcherTest>>#testHenry097Method has no comment.RxMatcherTest>>#testHenry098Method has no comment.RxMatcherTest>>#testHenry099Method has no comment.RxMatcherTest>>#testHenry100Method has no comment.RxMatcherTest>>#testHenry101Method has no comment.RxMatcherTest>>#testHenry102Method has no comment.RxMatcherTest>>#testHenry103Method has no comment.RxMatcherTest>>#testHenry104Method has no comment.RxMatcherTest>>#testHenry105Method has no comment.RxMatcherTest>>#testHenry106Method has no comment.RxMatcherTest>>#testHenry107Method has no comment.RxMatcherTest>>#testHenry108Method has no comment.RxMatcherTest>>#testHenry109Method has no comment.RxMatcherTest>>#testHenry110Method has no comment.RxMatcherTest>>#testHenry111Method has no comment.RxMatcherTest>>#testHenry112Method has no comment.RxMatcherTest>>#testHenry113Method has no comment.RxMatcherTest>>#testHenry114Method has no comment.RxMatcherTest>>#testHenry115Method has no comment.RxMatcherTest>>#testHenry116Method has no comment.RxMatcherTest>>#testHenry117Method has no comment.RxMatcherTest>>#testHenry118Method has no comment.RxMatcherTest>>#testHenry119Method has no comment.RxMatcherTest>>#testHenry120Method has no comment.RxMatcherTest>>#testHenry121Method has no comment.RxMatcherTest>>#testHenry122Method has no comment.RxMatcherTest>>#testHenry123Method has no comment.RxMatcherTest>>#testHenry124Method has no comment.RxMatcherTest>>#testHenry125Method has no comment.RxMatcherTest>>#testHenry126Method has no comment.RxMatcherTest>>#testHenry127Method has no comment.RxMatcherTest>>#testHenry128Method has no comment.RxMatcherTest>>#testHenry129Method has no comment.RxMatcherTest>>#testHenry130Method has no comment.RxMatcherTest>>#testHenry131Method has no comment.RxMatcherTest>>#testHenry132Method has no comment.RxMatcherTest>>#testHenry133Method has no comment.RxMatcherTest>>#testHenry134Method has no comment.RxMatcherTest>>#testHenry135Method has no comment.RxMatcherTest>>#testHenry136Method has no comment.RxMatcherTest>>#testHenry137Method has no comment.RxMatcherTest>>#testMatchesMethod has no comment.RxMatcherTest>>#testMatchesInMethod has no comment.RxMatcherTest>>#testMatchesInCollectMethod has no comment.RxMatcherTest>>#testMatchesInDoMethod has no comment.RxMatcherTest>>#testMatchesOnStreamMethod has no comment.RxMatcherTest>>#testMatchesOnStreamCollectMethod has no comment.RxMatcherTest>>#testMatchesOnStreamDoMethod has no comment.RxMatcherTest>>#testMatchesStreamMethod has no comment.RxMatcherTest>>#testMatchingRangesInMethod has no comment.RxMatcherTest>>#testRegex001Method has no comment.RxMatcherTest>>#testRegex002Method has no comment.RxMatcherTest>>#testRegex003Method has no comment.RxMatcherTest>>#testRegex004Method has no comment.RxMatcherTest>>#testStringAllRangesOfRegexMatchesMethod has no comment.RxMatcherTest>>#testStringAllRegexMatchesMethod has no comment.RxMatcherTest>>#testStringAsRegexMethod has no comment.RxMatcherTest>>#testStringAsRegexIgnoringCaseMethod has no comment.RxMatcherTest>>#testStringCopyWithRegexMatchesReplacedWithMethod has no comment.RxMatcherTest>>#testStringCopyWithRegexMatchesTranslatedUsingMethod has no comment.RxMatcherTest>>#testStringGreedyMatchesRegexMethod has no comment.RxMatcherTest>>#testStringMatchesRegexMethod has no comment.RxMatcherTest>>#testStringMatchesRegexIgnoringCaseMethod has no comment.RxMatcherTest>>#testStringPrefixMatchesRegexMethod has no comment.RxMatcherTest>>#testStringPrefixMatchesRegexIgnoringCaseMethod has no comment.RxMatcherTest>>#testStringRegexMatchesCollectMethod has no comment.RxMatcherTest>>#testStringRegexMatchesDoMethod has no comment.RxMatcherTest>>#testSubexpressionCountMethod has no comment.##### Class sideRxMatcherTest class>>#packageNamesUnderTestMethod has no comment.#### RxParserTestThis class provides tests for the regular expression parser.##### Instance sideRxParserTest>>#DoesNotWorktestBackQuotesEscapeRegular expressions can also include the following backquote escapesto refer to popular classes of characters:	\w	any word constituent character (same as [a-zA-Z0-9:=])	\W	any character but a word constituent	\d	a digit (same as [0-9])	\D	anything but a digit	\s 	a whitespace character	\S	anything but a whitespace characterThese escapes are also allowed in character classes: '[\w+-]' means'any character that is either a word constituent, or a plus, or aminus'.RxParserTest>>#testMethod has no comment.RxParserTest>>#testCadrMatchingA bit more complex example is the following expression, matching thename of any of the Lisp-style `car', `cdr', `caar', `cadr',... functions:RxParserTest>>#testCharacterSetSo far, we have used only characters as the 'smallest' components ofregular expressions. There are other, more `interesting', components.A character set is a string of characters enclosed in squarebrackets. It matches any single character if it appears between thebrackets. For example, `[01]' matches either `0' or `1':RxParserTest>>#testCharacterSetBinaryNumberUsing plus operator, we can build the following binary numberrecognizer:RxParserTest>>#testCharacterSetInversionIf the first character after the opening bracket is `^', the set isinverted: it matches any single character *not* appearing between thebrackets:RxParserTest>>#testCharacterSetRangeFor convenience, a set may include ranges: pairs of charactersseparated with `-'. This is equivalent to listing all charactersbetween them: `[0-9]' is the same as `[0123456789]'. RxParserTest>>#testLookaroundMethod has no comment.RxParserTest>>#testMatchesInwW1. Backslash escapes similar to those in Perl are allowed in patterns:	\w	any word constituent character (equivalent to [a-zA-Z0-9:=])	\W	any character but a word constituent (equivalent to [^a-xA-Z0-9:=]RxParserTest>>#testOrOperatorThe last operator is `|' meaning `or'. It is placed between tworegular expressions, and the resulting expression matches if one ofthe expressions matches. It has the lowest possible precedence (lowerthan sequencing). For example, `ab*|ba*' means `a followed by anynumber of b's, or b followed by any number of a's':RxParserTest>>#testQuantifierMethod has no comment.RxParserTest>>#testQuantifierSimpleTest quantifier expressions that can be expressed with + or *RxParserTest>>#testQuotingOperatorsAs we have seen, characters `*', `+', `?', `(', and `)' have specialmeaning in regular expressions. If one of them is to be usedliterally, it should be quoted: preceded with a backslash. (Thus,backslash is also special character, and needs to be quoted for aliteral match--as well as any other special character describedfurther).RxParserTest>>#testSimpleMatchesRegexThe simplest regular expression is a single character.  It matchesexactly that character. A sequence of characters matches a string withexactly the same sequence of characters:RxParserTest>>#testSimpleMatchesRegexWithStarThe above paragraph in testSimpleMatchesRegex introduced a primitive regular expression (acharacter), and an operator (sequencing). Operators are applied toregular expressions to produce more complex regular expressions.Sequencing (placing expressions one after another) as an operator is,in a certain sense, `invisible'--yet it is arguably the most common.A more `visible' operator is Kleene closure, more often simplyreferred to as `a star'.  A regular expression followed by an asteriskmatches any number (including 0) of matches of the originalexpression. For example:RxParserTest>>#testSpecialCharacterInSetRangeSpecial characters within a set are `^', `-', and `]' that closes theset. Below are the examples of how to literally use them in a set:	[01^]		-- put the caret anywhere except the beginning	[01-]		-- put the dash as the last character	[]01]		-- put the closing bracket as the first character 	[^]01]			(thus, empty and universal sets cannot be specified)RxParserTest>>#testStarPlusQuestionMarkTwo other operators similar to `*' are `+' and `?'. `+' (positiveclosure, or simply `plus') matches one or more occurrences of theoriginal expression. `?' (`optional') matches zero or one, but nevermore, occurrences.RxParserTest>>#testStarPrecedenceA star's precedence is higher than that of sequencing. A star appliesto the shortest possible subexpression that precedes it. For example,'ab*' means `a followed by zero or more occurrences of b', not `zeroor more occurrences of ab':RxParserTest>>#testTranslatingMatchesUsingMethod has no comment.##### Class side