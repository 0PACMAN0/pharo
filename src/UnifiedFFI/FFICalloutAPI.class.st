"
I'm a faÃ§ade to perform ffi nb calls.
"
Class {
	#name : #FFICalloutAPI,
	#superclass : #Object,
	#instVars : [
		'context',
		'options',
		'callingConvention'
	],
	#classVars : [
		'CalloutAPIClass'
	],
	#category : #'UnifiedFFI-Callouts'
}

{ #category : #accessing }
FFICalloutAPI class >> calloutAPIClass [
	^ CalloutAPIClass ifNil: [ CalloutAPIClass := self defaultCalloutAPIClass ]
	
]

{ #category : #accessing }
FFICalloutAPI class >> calloutAPIClass: aClass [
	CalloutAPIClass := aClass
]

{ #category : #accessing }
FFICalloutAPI class >> defaultCalloutAPIClass [
	^ FFICalloutAPI	
]

{ #category : #'instance creation' }
FFICalloutAPI class >> inContext: aContext [
	^ self basicNew 
		initializeContext: aContext;
		yourself
]

{ #category : #'instance creation' }
FFICalloutAPI class >> new [ 
	self error: 'Use #inContext'
]

{ #category : #private }
FFICalloutAPI class >> newCallbackBackendFor: aCallback [

	^ FFIAlienCallback fromFrontendCallback: aCallback
]

{ #category : #private }
FFICalloutAPI >> callingConvention [
	^ callingConvention
]

{ #category : #'call conventions' }
FFICalloutAPI >> cdecl [
	callingConvention := #cdecl
]

{ #category : #accessing }
FFICalloutAPI >> context [
	^ context
]

{ #category : #accessing }
FFICalloutAPI >> convention: aCallingConvention [
	"It can be #cdecl or #stdcall"
	callingConvention := aCallingConvention
]

{ #category : #action }
FFICalloutAPI >> function: functionSignature library: aLibrary [
	| sender ffiMethod ffiMethodSelector |
	sender := self senderContext.
	ffiMethodSelector := self uFFIEnterMethodSelector.

	"Build new method"
	ffiMethod := self newBuilder
		build: [ :builder | 
			builder
				signature: functionSignature;
				sender: sender;
				module: aLibrary ].
	ffiMethod
		selector: sender selector;
		methodClass: sender methodClass.
	"Replace with generated ffi method, but save old one for future use"
	ffiMethod propertyValueAt: #ffiNonCompiledMethod put: (sender methodClass methodDict at: sender selector).
	"For senders search, one need to keep the selector in the properties"
	ffiMethod propertyValueAt: #ffiMethodSelector put: ffiMethodSelector.
	sender methodClass methodDict at: sender selector put: ffiMethod.
	"Register current method as compiled for ffi"
	FFIMethodRegistry uniqueInstance registerMethod: ffiMethod.
	"Resend"
	sender return: (sender receiver withArgs: sender arguments executeMethod: ffiMethod)
]

{ #category : #action }
FFICalloutAPI >> function: functionSignature module: moduleNameOrLibrary [
	
	^ self function: functionSignature library: moduleNameOrLibrary
]

{ #category : #initialization }
FFICalloutAPI >> initialize [
	callingConvention := #cdecl.
	options := #().
	super initialize
]

{ #category : #initialization }
FFICalloutAPI >> initializeContext: aContext [
	context := aContext.
	self initialize
]

{ #category : #action }
FFICalloutAPI >> newBuilder [
	^ FFICalloutMethodBuilder calloutAPI: self
]

{ #category : #'as yet unclassified' }
FFICalloutAPI >> newCallbackWithSignature: signature block: aBlock library: aLibrary [

	^ (FFICallback signature: signature block: aBlock)
		calloutAPIClass: self class;
		ffiLibrary: aLibrary;
		yourself
]

{ #category : #accessing }
FFICalloutAPI >> options [
	^ options
]

{ #category : #accessing }
FFICalloutAPI >> options: anObject [
	options := anObject
]

{ #category : #accessing }
FFICalloutAPI >> senderContext [
	
	^ self uffiEnterContext sender
]

{ #category : #'call conventions' }
FFICalloutAPI >> stdcall [
	callingConvention := #stdcall
]

{ #category : #accessing }
FFICalloutAPI >> uFFIEnterMethodSelector [
	
	"Return the selector of the uffiEnterContext.
	That is, the selector that was called by client code to invoke uffi "
	^ self uffiEnterContext method selector
]

{ #category : #configuration }
FFICalloutAPI >> uffiEnterContext [
	"Finds the initial context where entering the uffi framework.
	That is, the context that was marked with the #ffiCalloutTranslator pragma, whose caller was not.
	The found context determines how uffi was called. Its sender context is the client context.
	
	Return the selector of the uffiEnterContext "
	| pragmaName uffiEnterContext |
	pragmaName := #ffiCalloutTranslator.
	
	uffiEnterContext := context findContextSuchThat: [ :ctx |
		(ctx method hasPragmaNamed: pragmaName)
			and: [ (ctx sender method hasPragmaNamed: pragmaName) not] ].
	^ uffiEnterContext
]
